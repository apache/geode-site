<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Geode Native C++ Reference: apache::geode::client::PdxReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Geode Native C++ Reference
   &#160;<span id="projectnumber">1.14.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00767.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">apache::geode::client::PdxReader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> will be passed to <a class="el" href="a00771.html#aa2429785803446f892d6669d7ebab795" title="Deserialize this object.">PdxSerializable.fromData</a> or during deserialization of a PDX.  
 <a href="a00767.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2051d8d9185ab312194bb0dfe48ef7de"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de">hasField</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a2051d8d9185ab312194bb0dfe48ef7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field exists and returns the result.  <a href="#a2051d8d9185ab312194bb0dfe48ef7de">More...</a><br /></td></tr>
<tr class="separator:a2051d8d9185ab312194bb0dfe48ef7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b5d8bb5f7488b7984c14106245ae3f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#ab5b5d8bb5f7488b7984c14106245ae3f">isIdentityField</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:ab5b5d8bb5f7488b7984c14106245ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field was <a class="el" href="a00787.html#a4284cab342603084f26e40658ee66819">PdxWriter#markIdentityField</a>marked as an identity field.  <a href="#ab5b5d8bb5f7488b7984c14106245ae3f">More...</a><br /></td></tr>
<tr class="separator:ab5b5d8bb5f7488b7984c14106245ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dcb925fad3dff4f8bc7dac6cee8aa7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a12dcb925fad3dff4f8bc7dac6cee8aa7">PdxReader</a> ()</td></tr>
<tr class="memdesc:a12dcb925fad3dff4f8bc7dac6cee8aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructors  <a href="#a12dcb925fad3dff4f8bc7dac6cee8aa7">More...</a><br /></td></tr>
<tr class="separator:a12dcb925fad3dff4f8bc7dac6cee8aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92efb8f0a519793c1a59955ae19e76d"><td class="memItemLeft" align="right" valign="top">virtual int8_t **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#ac92efb8f0a519793c1a59955ae19e76d">readArrayOfByteArrays</a> (const std::string &amp;fieldName, int32_t &amp;arrayLength, int32_t **elementLength)=0</td></tr>
<tr class="memdesc:ac92efb8f0a519793c1a59955ae19e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int8_t** value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets ArrayOfByteArray's length and individual ByteArray's length.  <a href="#ac92efb8f0a519793c1a59955ae19e76d">More...</a><br /></td></tr>
<tr class="separator:ac92efb8f0a519793c1a59955ae19e76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291c4c5fcd68744f59938712b901cc88"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a291c4c5fcd68744f59938712b901cc88">readBoolean</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a291c4c5fcd68744f59938712b901cc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bool value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a291c4c5fcd68744f59938712b901cc88">More...</a><br /></td></tr>
<tr class="separator:a291c4c5fcd68744f59938712b901cc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03fe9cac84990a764430a9bbf7013f7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#af03fe9cac84990a764430a9bbf7013f7">readBooleanArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:af03fe9cac84990a764430a9bbf7013f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bool* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#af03fe9cac84990a764430a9bbf7013f7">More...</a><br /></td></tr>
<tr class="separator:af03fe9cac84990a764430a9bbf7013f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c52c6db0f725279924edf28a8c9152a"><td class="memItemLeft" align="right" valign="top">virtual int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a1c52c6db0f725279924edf28a8c9152a">readByte</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a1c52c6db0f725279924edf28a8c9152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int8_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a1c52c6db0f725279924edf28a8c9152a">More...</a><br /></td></tr>
<tr class="separator:a1c52c6db0f725279924edf28a8c9152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de5edf806ee2d4b5c2193b490ce46fd"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a8de5edf806ee2d4b5c2193b490ce46fd">readByteArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a8de5edf806ee2d4b5c2193b490ce46fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int8_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#a8de5edf806ee2d4b5c2193b490ce46fd">More...</a><br /></td></tr>
<tr class="separator:a8de5edf806ee2d4b5c2193b490ce46fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221146e6898f4f320542e5b2be945dd9"><td class="memItemLeft" align="right" valign="top">virtual char16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a221146e6898f4f320542e5b2be945dd9">readChar</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a221146e6898f4f320542e5b2be945dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a wide char value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a221146e6898f4f320542e5b2be945dd9">More...</a><br /></td></tr>
<tr class="separator:a221146e6898f4f320542e5b2be945dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d0c020e3a65e5314f0efe6738d9fd4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; char16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a53d0c020e3a65e5314f0efe6738d9fd4">readCharArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a53d0c020e3a65e5314f0efe6738d9fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a char16_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#a53d0c020e3a65e5314f0efe6738d9fd4">More...</a><br /></td></tr>
<tr class="separator:a53d0c020e3a65e5314f0efe6738d9fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eac3c3a601459c1dbf84e8a2be25336"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00327.html">CacheableDate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a5eac3c3a601459c1dbf84e8a2be25336">readDate</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a5eac3c3a601459c1dbf84e8a2be25336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a std::shared_ptr&lt;CacheableDate&gt; value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a5eac3c3a601459c1dbf84e8a2be25336">More...</a><br /></td></tr>
<tr class="separator:a5eac3c3a601459c1dbf84e8a2be25336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611e0fc73c5b7554f8cb2e9a3e09aeb4"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a611e0fc73c5b7554f8cb2e9a3e09aeb4">readDouble</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a611e0fc73c5b7554f8cb2e9a3e09aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a double value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a611e0fc73c5b7554f8cb2e9a3e09aeb4">More...</a><br /></td></tr>
<tr class="separator:a611e0fc73c5b7554f8cb2e9a3e09aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e716e233cf09b429f780b1e7569c41b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a1e716e233cf09b429f780b1e7569c41b">readDoubleArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a1e716e233cf09b429f780b1e7569c41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a double* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#a1e716e233cf09b429f780b1e7569c41b">More...</a><br /></td></tr>
<tr class="separator:a1e716e233cf09b429f780b1e7569c41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744922401cbcfbabdd8052d363e004c9"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a744922401cbcfbabdd8052d363e004c9">readFloat</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a744922401cbcfbabdd8052d363e004c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a float value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a744922401cbcfbabdd8052d363e004c9">More...</a><br /></td></tr>
<tr class="separator:a744922401cbcfbabdd8052d363e004c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631f8c1bd8618cf2e5f7c4e51616df10"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a631f8c1bd8618cf2e5f7c4e51616df10">readFloatArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a631f8c1bd8618cf2e5f7c4e51616df10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a float* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#a631f8c1bd8618cf2e5f7c4e51616df10">More...</a><br /></td></tr>
<tr class="separator:a631f8c1bd8618cf2e5f7c4e51616df10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade868104eb87bf2eb677c3eb8bf6e0f4"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#ade868104eb87bf2eb677c3eb8bf6e0f4">readInt</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:ade868104eb87bf2eb677c3eb8bf6e0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int32_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#ade868104eb87bf2eb677c3eb8bf6e0f4">More...</a><br /></td></tr>
<tr class="separator:ade868104eb87bf2eb677c3eb8bf6e0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f415099aae6112faebadc8bcffe84c8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a4f415099aae6112faebadc8bcffe84c8">readIntArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a4f415099aae6112faebadc8bcffe84c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int32_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#a4f415099aae6112faebadc8bcffe84c8">More...</a><br /></td></tr>
<tr class="separator:a4f415099aae6112faebadc8bcffe84c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cb7e8516f2cbd762b2975b17776556"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#af3cb7e8516f2cbd762b2975b17776556">readLong</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:af3cb7e8516f2cbd762b2975b17776556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int64_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#af3cb7e8516f2cbd762b2975b17776556">More...</a><br /></td></tr>
<tr class="separator:af3cb7e8516f2cbd762b2975b17776556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9442862993f46669adc1a9001ac63426"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a9442862993f46669adc1a9001ac63426">readLongArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a9442862993f46669adc1a9001ac63426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int64_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#a9442862993f46669adc1a9001ac63426">More...</a><br /></td></tr>
<tr class="separator:a9442862993f46669adc1a9001ac63426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f409ec8eac96e690290af4579b6e1a3"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00863.html">Cacheable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a3f409ec8eac96e690290af4579b6e1a3">readObject</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a3f409ec8eac96e690290af4579b6e1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a std::shared_ptr&lt;Cacheable&gt; value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a3f409ec8eac96e690290af4579b6e1a3">More...</a><br /></td></tr>
<tr class="separator:a3f409ec8eac96e690290af4579b6e1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855930520331ee808dc1c24aca01c3b3"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00355.html">CacheableObjectArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a855930520331ee808dc1c24aca01c3b3">readObjectArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a855930520331ee808dc1c24aca01c3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a std::shared_ptr&lt;CacheableObjectArray&gt; value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a855930520331ee808dc1c24aca01c3b3">More...</a><br /></td></tr>
<tr class="separator:a855930520331ee808dc1c24aca01c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb104c80503a950b44e1efb2b9fba3e"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a3cb104c80503a950b44e1efb2b9fba3e">readShort</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a3cb104c80503a950b44e1efb2b9fba3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int16_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a3cb104c80503a950b44e1efb2b9fba3e">More...</a><br /></td></tr>
<tr class="separator:a3cb104c80503a950b44e1efb2b9fba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada334eaa27b15f2f6e86ff2ef022d548"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#ada334eaa27b15f2f6e86ff2ef022d548">readShortArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:ada334eaa27b15f2f6e86ff2ef022d548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a int16_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length.  <a href="#ada334eaa27b15f2f6e86ff2ef022d548">More...</a><br /></td></tr>
<tr class="separator:ada334eaa27b15f2f6e86ff2ef022d548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8eacc3791b4ee9539491659c298257"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#aaf8eacc3791b4ee9539491659c298257">readString</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:aaf8eacc3791b4ee9539491659c298257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a std::string value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#aaf8eacc3791b4ee9539491659c298257">More...</a><br /></td></tr>
<tr class="separator:aaf8eacc3791b4ee9539491659c298257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ad8e42f16e2cb89db90da6a0ebca6e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a32ad8e42f16e2cb89db90da6a0ebca6e">readStringArray</a> (const std::string &amp;fieldName)=0</td></tr>
<tr class="memdesc:a32ad8e42f16e2cb89db90da6a0ebca6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a array of strings from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>.  <a href="#a32ad8e42f16e2cb89db90da6a0ebca6e">More...</a><br /></td></tr>
<tr class="separator:a32ad8e42f16e2cb89db90da6a0ebca6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a21d6413b8e59e7667bb74bb46b0e5"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00779.html">PdxUnreadFields</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a57a21d6413b8e59e7667bb74bb46b0e5">readUnreadFields</a> ()=0</td></tr>
<tr class="memdesc:a57a21d6413b8e59e7667bb74bb46b0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns an object that represents all the unread fields which must be passed to <a class="el" href="a00787.html#afe6e9828597463ee36403fa3e415eb8c">PdxWriter#writeUnreadFields</a> in the toData code.  <a href="#a57a21d6413b8e59e7667bb74bb46b0e5">More...</a><br /></td></tr>
<tr class="separator:a57a21d6413b8e59e7667bb74bb46b0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a15f7137d7e9cb7cfb9ea2fca16e677"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00767.html#a8a15f7137d7e9cb7cfb9ea2fca16e677">~PdxReader</a> ()</td></tr>
<tr class="memdesc:a8a15f7137d7e9cb7cfb9ea2fca16e677"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#a8a15f7137d7e9cb7cfb9ea2fca16e677">More...</a><br /></td></tr>
<tr class="separator:a8a15f7137d7e9cb7cfb9ea2fca16e677"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> will be passed to <a class="el" href="a00771.html#aa2429785803446f892d6669d7ebab795" title="Deserialize this object.">PdxSerializable.fromData</a> or during deserialization of a PDX. </p>
<p>The domain class needs to deserialize field members using this abstract class. This class is implemented by Native Client. Each readXXX call will return the field's value. If the serialized PDX does not contain the named field then a default value will be returned. Standard Java defaults are used. For Objects this is null and for primitives it is 0 or 0.0.</p>
<dl class="section note"><dt>Note</dt><dd>Implementations of <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> that are internal to the Native Client library may be returned to clients via instances of <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a>&amp;. For those implementations, any non-<code>nullptr</code>, non-empty strings returned from <a class="el" href="a00767.html#aaf8eacc3791b4ee9539491659c298257" title="Read a std::string value from the PdxReader.">PdxReader::readString()</a> or PdxReader::readWideString() must be freed with DataInput::freeUTFMemory(). Arrays returned from <a class="el" href="a00767.html#a32ad8e42f16e2cb89db90da6a0ebca6e" title="Read a array of strings from the PdxReader.">PdxReader::readStringArray()</a> or PdxReader::readWideStringArray() must be freed with <code>GF_SAFE_DELETE_ARRAY</code> once their constituent strings have been freed with DataInput::freeUTFMemory(). </dd>
<dd>
Custom implementations of <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> are not subject to this restriction. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a12dcb925fad3dff4f8bc7dac6cee8aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dcb925fad3dff4f8bc7dac6cee8aa7">&#9670;&nbsp;</a></span>PdxReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">apache::geode::client::PdxReader::PdxReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructors </p>

</div>
</div>
<a id="a8a15f7137d7e9cb7cfb9ea2fca16e677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a15f7137d7e9cb7cfb9ea2fca16e677">&#9670;&nbsp;</a></span>~PdxReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual apache::geode::client::PdxReader::~PdxReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2051d8d9185ab312194bb0dfe48ef7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2051d8d9185ab312194bb0dfe48ef7de">&#9670;&nbsp;</a></span>hasField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxReader::hasField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field exists and returns the result. </p>
<p>This can be useful when writing code that handles more than one version of a PDX class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="ab5b5d8bb5f7488b7984c14106245ae3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b5d8bb5f7488b7984c14106245ae3f">&#9670;&nbsp;</a></span>isIdentityField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxReader::isIdentityField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field was <a class="el" href="a00787.html#a4284cab342603084f26e40658ee66819">PdxWriter#markIdentityField</a>marked as an identity field. </p>
<p>Note that if no fields have been marked then all the fields are used as identity fields even though this method will return <code>false</code> since none of them have been <em>marked</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="ac92efb8f0a519793c1a59955ae19e76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92efb8f0a519793c1a59955ae19e76d">&#9670;&nbsp;</a></span>readArrayOfByteArrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t** apache::geode::client::PdxReader::readArrayOfByteArrays </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t **&#160;</td>
          <td class="paramname"><em>elementLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int8_t** value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets ArrayOfByteArray's length and individual ByteArray's length. </p>
<p>C++ int8_t** is mapped to Java byte[][].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">arrayLength</td><td>length is set with number of int8_t* elements </td></tr>
    <tr><td class="paramname">elementLength</td><td>elementLength is set with the length value of individual byte arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int8_t**. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a291c4c5fcd68744f59938712b901cc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291c4c5fcd68744f59938712b901cc88">&#9670;&nbsp;</a></span>readBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxReader::readBoolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bool value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ bool is mapped to Java boolean</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type bool. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="af03fe9cac84990a764430a9bbf7013f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03fe9cac84990a764430a9bbf7013f7">&#9670;&nbsp;</a></span>readBooleanArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;bool&gt; apache::geode::client::PdxReader::readBooleanArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bool* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ bool* is mapped to Java boolean[]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a1c52c6db0f725279924edf28a8c9152a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c52c6db0f725279924edf28a8c9152a">&#9670;&nbsp;</a></span>readByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t apache::geode::client::PdxReader::readByte </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int8_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ int8_t is mapped to Java byte</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int8_t. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a8de5edf806ee2d4b5c2193b490ce46fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de5edf806ee2d4b5c2193b490ce46fd">&#9670;&nbsp;</a></span>readByteArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int8_t&gt; apache::geode::client::PdxReader::readByteArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int8_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ int8_t* is mapped to Java byte[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int8_t*. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a221146e6898f4f320542e5b2be945dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221146e6898f4f320542e5b2be945dd9">&#9670;&nbsp;</a></span>readChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char16_t apache::geode::client::PdxReader::readChar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a wide char value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ char16_t is mapped to Java char</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type wchar_t. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a53d0c020e3a65e5314f0efe6738d9fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d0c020e3a65e5314f0efe6738d9fd4">&#9670;&nbsp;</a></span>readCharArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;char16_t&gt; apache::geode::client::PdxReader::readCharArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a char16_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ char16_t* is mapped to Java char[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type char16_t*. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a5eac3c3a601459c1dbf84e8a2be25336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eac3c3a601459c1dbf84e8a2be25336">&#9670;&nbsp;</a></span>readDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00327.html">CacheableDate</a>&gt; apache::geode::client::PdxReader::readDate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a std::shared_ptr&lt;CacheableDate&gt; value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ std::shared_ptr&lt;CacheableDate&gt; is mapped to Java Date</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type std::shared_ptr&lt;CacheableDate&gt;. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a611e0fc73c5b7554f8cb2e9a3e09aeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611e0fc73c5b7554f8cb2e9a3e09aeb4">&#9670;&nbsp;</a></span>readDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double apache::geode::client::PdxReader::readDouble </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a double value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ double is mapped to Java double</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type double. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a1e716e233cf09b429f780b1e7569c41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e716e233cf09b429f780b1e7569c41b">&#9670;&nbsp;</a></span>readDoubleArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;double&gt; apache::geode::client::PdxReader::readDoubleArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a double* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ double* is mapped to Java double[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type double*. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a744922401cbcfbabdd8052d363e004c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744922401cbcfbabdd8052d363e004c9">&#9670;&nbsp;</a></span>readFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float apache::geode::client::PdxReader::readFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a float value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ float is mapped to Java float</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type float. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a631f8c1bd8618cf2e5f7c4e51616df10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631f8c1bd8618cf2e5f7c4e51616df10">&#9670;&nbsp;</a></span>readFloatArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;float&gt; apache::geode::client::PdxReader::readFloatArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a float* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ float* is mapped to Java float[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type float*. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="ade868104eb87bf2eb677c3eb8bf6e0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade868104eb87bf2eb677c3eb8bf6e0f4">&#9670;&nbsp;</a></span>readInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::PdxReader::readInt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int32_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ int32_t is mapped to Java int</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int32_t. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a4f415099aae6112faebadc8bcffe84c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f415099aae6112faebadc8bcffe84c8">&#9670;&nbsp;</a></span>readIntArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int32_t&gt; apache::geode::client::PdxReader::readIntArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int32_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ int32_t* is mapped to Java int[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int32_t*. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="af3cb7e8516f2cbd762b2975b17776556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cb7e8516f2cbd762b2975b17776556">&#9670;&nbsp;</a></span>readLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t apache::geode::client::PdxReader::readLong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int64_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ int64_t is mapped to Java long</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int64_t. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a9442862993f46669adc1a9001ac63426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9442862993f46669adc1a9001ac63426">&#9670;&nbsp;</a></span>readLongArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int64_t&gt; apache::geode::client::PdxReader::readLongArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int64_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ int64_t* is mapped to Java long[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int64_t*. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a3f409ec8eac96e690290af4579b6e1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f409ec8eac96e690290af4579b6e1a3">&#9670;&nbsp;</a></span>readObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00863.html">Cacheable</a>&gt; apache::geode::client::PdxReader::readObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a std::shared_ptr&lt;Cacheable&gt; value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ std::shared_ptr&lt;Cacheable&gt; is mapped to Java object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type std::shared_ptr&lt;Cacheable&gt;. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a855930520331ee808dc1c24aca01c3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855930520331ee808dc1c24aca01c3b3">&#9670;&nbsp;</a></span>readObjectArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00355.html">CacheableObjectArray</a>&gt; apache::geode::client::PdxReader::readObjectArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a std::shared_ptr&lt;CacheableObjectArray&gt; value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ std::shared_ptr&lt;CacheableObjectArray&gt; is mapped to Java Object[]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type std::shared_ptr&lt;CacheableObjectArray&gt;. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a3cb104c80503a950b44e1efb2b9fba3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb104c80503a950b44e1efb2b9fba3e">&#9670;&nbsp;</a></span>readShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t apache::geode::client::PdxReader::readShort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int16_t value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ int16_t is mapped to Java short</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int16_t. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="ada334eaa27b15f2f6e86ff2ef022d548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada334eaa27b15f2f6e86ff2ef022d548">&#9670;&nbsp;</a></span>readShortArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int16_t&gt; apache::geode::client::PdxReader::readShortArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a int16_t* value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code> and sets array length. </p>
<p>C++ int16_t* is mapped to Java short[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type int16_t*. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="aaf8eacc3791b4ee9539491659c298257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8eacc3791b4ee9539491659c298257">&#9670;&nbsp;</a></span>readString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string apache::geode::client::PdxReader::readString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a std::string value from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ std::string is mapped to Java String</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type std::string*. Refer to the class description for how to free the return value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a32ad8e42f16e2cb89db90da6a0ebca6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ad8e42f16e2cb89db90da6a0ebca6e">&#9670;&nbsp;</a></span>readStringArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; apache::geode::client::PdxReader::readStringArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a array of strings from the <code><a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></code>. </p>
<p>C++ std::vector&lt;std::string&gt; is mapped to Java String[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type std::vector&lt;std::string&gt;. Refer to the class description for how to free the return value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00767.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00767.html#a2051d8d9185ab312194bb0dfe48ef7de" title="Checks if the named field exists and returns the result.">PdxReader::hasField</a> </dd></dl>

</div>
</div>
<a id="a57a21d6413b8e59e7667bb74bb46b0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a21d6413b8e59e7667bb74bb46b0e5">&#9670;&nbsp;</a></span>readUnreadFields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00779.html">PdxUnreadFields</a>&gt; apache::geode::client::PdxReader::readUnreadFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns an object that represents all the unread fields which must be passed to <a class="el" href="a00787.html#afe6e9828597463ee36403fa3e415eb8c">PdxWriter#writeUnreadFields</a> in the toData code. </p>
<p>Note that if <a class="el" href="a00371.html#a34b24c080cc3533f668e9f827f987a64">CacheFactory#setPdxIgnoreUnreadFields</a> is set to <code>true</code> then this method will always return an object that has no unread fields.</p>
<dl class="section return"><dt>Returns</dt><dd>an object that represents the unread fields. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<HR><address style="align: right;"><small>Apache Geode C++ Cache API Documentation</small></address>
