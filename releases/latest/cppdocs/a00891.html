<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Geode Native C++ Reference: apache::geode::client::WritablePdxInstance Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Geode Native C++ Reference
   &#160;<span id="projectnumber">1.14.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00891.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">apache::geode::client::WritablePdxInstance Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> is a <a class="el" href="a00759.html">PdxInstance</a> that also supports field modification using the <a class="el" href="a00891.html#a150bcbfaa96659faaa1da67ab9f6c234">setField</a> method.  
 <a href="a00891.html#details">More...</a></p>

<p>Inherits <a class="el" href="a00759.html">apache::geode::client::PdxInstance</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8e8a42bfedd76fec24cfff33fbdd93a"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00891.html">WritablePdxInstance</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#af8e8a42bfedd76fec24cfff33fbdd93a">createWriter</a> ()=0</td></tr>
<tr class="memdesc:af8e8a42bfedd76fec24cfff33fbdd93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="a00891.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#af8e8a42bfedd76fec24cfff33fbdd93a">More...</a><br /></td></tr>
<tr class="separator:af8e8a42bfedd76fec24cfff33fbdd93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e789d8e4da85f4ec586bd16b737001"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#aa3e789d8e4da85f4ec586bd16b737001">fromData</a> (<a class="el" href="a00767.html">PdxReader</a> &amp;input) override=0</td></tr>
<tr class="memdesc:aa3e789d8e4da85f4ec586bd16b737001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize this object.  <a href="#aa3e789d8e4da85f4ec586bd16b737001">More...</a><br /></td></tr>
<tr class="separator:aa3e789d8e4da85f4ec586bd16b737001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a96b719b63a9cbc7eb63f2781cae7d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#ad6a96b719b63a9cbc7eb63f2781cae7d">getBooleanArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:ad6a96b719b63a9cbc7eb63f2781cae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in bool array type out param.  <a href="#ad6a96b719b63a9cbc7eb63f2781cae7d">More...</a><br /></td></tr>
<tr class="separator:ad6a96b719b63a9cbc7eb63f2781cae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14050655be9f0e5d0b98ca8cd58ebe7f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a14050655be9f0e5d0b98ca8cd58ebe7f">getBooleanField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a14050655be9f0e5d0b98ca8cd58ebe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in bool type out param.  <a href="#a14050655be9f0e5d0b98ca8cd58ebe7f">More...</a><br /></td></tr>
<tr class="separator:a14050655be9f0e5d0b98ca8cd58ebe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5367cf178da27aecddc44ac48ce595"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a6a5367cf178da27aecddc44ac48ce595">getByteArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a6a5367cf178da27aecddc44ac48ce595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in signed char array type out param.  <a href="#a6a5367cf178da27aecddc44ac48ce595">More...</a><br /></td></tr>
<tr class="separator:a6a5367cf178da27aecddc44ac48ce595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48742741670329aba1d48b25964f2789"><td class="memItemLeft" align="right" valign="top">virtual int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a48742741670329aba1d48b25964f2789">getByteField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a48742741670329aba1d48b25964f2789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in signed char type out param.  <a href="#a48742741670329aba1d48b25964f2789">More...</a><br /></td></tr>
<tr class="separator:a48742741670329aba1d48b25964f2789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813be08753e160b30b0353c9cc5cd0c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00327.html">CacheableDate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#ad813be08753e160b30b0353c9cc5cd0c">getCacheableDateField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:ad813be08753e160b30b0353c9cc5cd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in std::shared_ptr&lt;CacheableDate&gt; type out param.  <a href="#ad813be08753e160b30b0353c9cc5cd0c">More...</a><br /></td></tr>
<tr class="separator:ad813be08753e160b30b0353c9cc5cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbe4efe8ed166011ff68a76e78ba96c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00863.html">Cacheable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#affbe4efe8ed166011ff68a76e78ba96c">getCacheableField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:affbe4efe8ed166011ff68a76e78ba96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in std::shared_ptr&lt;Cacheable&gt; type out param.  <a href="#affbe4efe8ed166011ff68a76e78ba96c">More...</a><br /></td></tr>
<tr class="separator:affbe4efe8ed166011ff68a76e78ba96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b598e4b18862e6e6788a6ba24a05d0"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00355.html">CacheableObjectArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a08b598e4b18862e6e6788a6ba24a05d0">getCacheableObjectArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a08b598e4b18862e6e6788a6ba24a05d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in std::shared_ptr&lt;CacheableObjectArray&gt; type out param.  <a href="#a08b598e4b18862e6e6788a6ba24a05d0">More...</a><br /></td></tr>
<tr class="separator:a08b598e4b18862e6e6788a6ba24a05d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cc4bf08dbaceb3cd8b59b5015b364f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; char16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#ae9cc4bf08dbaceb3cd8b59b5015b364f">getCharArrayField</a> (const std::string &amp;fieldName) const =0</td></tr>
<tr class="memdesc:ae9cc4bf08dbaceb3cd8b59b5015b364f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in char array type out param.  <a href="#ae9cc4bf08dbaceb3cd8b59b5015b364f">More...</a><br /></td></tr>
<tr class="separator:ae9cc4bf08dbaceb3cd8b59b5015b364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88b879c6497ebea32d09be9a85964d3"><td class="memItemLeft" align="right" valign="top">virtual char16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#ad88b879c6497ebea32d09be9a85964d3">getCharField</a> (const std::string &amp;fieldName) const =0</td></tr>
<tr class="memdesc:ad88b879c6497ebea32d09be9a85964d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in char type out param.  <a href="#ad88b879c6497ebea32d09be9a85964d3">More...</a><br /></td></tr>
<tr class="separator:ad88b879c6497ebea32d09be9a85964d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2912c23ab766cb21e711088dd3b0c1fb"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a2912c23ab766cb21e711088dd3b0c1fb">getClassName</a> () const override=0</td></tr>
<tr class="memdesc:a2912c23ab766cb21e711088dd3b0c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full name of the class that this pdx instance represents.  <a href="#a2912c23ab766cb21e711088dd3b0c1fb">More...</a><br /></td></tr>
<tr class="separator:a2912c23ab766cb21e711088dd3b0c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba80875c282330e1d20e7846506ec70"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a9ba80875c282330e1d20e7846506ec70">getDoubleArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a9ba80875c282330e1d20e7846506ec70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in double array type out param.  <a href="#a9ba80875c282330e1d20e7846506ec70">More...</a><br /></td></tr>
<tr class="separator:a9ba80875c282330e1d20e7846506ec70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdaa0cbd2791e46eb56b34f7d945bfa"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#accdaa0cbd2791e46eb56b34f7d945bfa">getDoubleField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:accdaa0cbd2791e46eb56b34f7d945bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in double type out param.  <a href="#accdaa0cbd2791e46eb56b34f7d945bfa">More...</a><br /></td></tr>
<tr class="separator:accdaa0cbd2791e46eb56b34f7d945bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676bf0537b037822cc335e69068c078a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a676bf0537b037822cc335e69068c078a">getField</a> (const std::string &amp;fieldName, int8_t ***value, int32_t &amp;arrayLength, int32_t *&amp;elementLength) const =0</td></tr>
<tr class="memdesc:a676bf0537b037822cc335e69068c078a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in array of byte arrays type out param.  <a href="#a676bf0537b037822cc335e69068c078a">More...</a><br /></td></tr>
<tr class="separator:a676bf0537b037822cc335e69068c078a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3cb5ba5c09771f1cc30238e54a7c3d"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00026.html#abb5c1ce32786fe2c0f7793809b103737">CacheableStringArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#aef3cb5ba5c09771f1cc30238e54a7c3d">getFieldNames</a> ()=0</td></tr>
<tr class="memdesc:aef3cb5ba5c09771f1cc30238e54a7c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unmodifiable list of the field names on this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#aef3cb5ba5c09771f1cc30238e54a7c3d">More...</a><br /></td></tr>
<tr class="separator:aef3cb5ba5c09771f1cc30238e54a7c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3cce44ea9beec3803807e5ab744723"><td class="memItemLeft" align="right" valign="top">virtual PdxFieldTypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#acc3cce44ea9beec3803807e5ab744723">getFieldType</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:acc3cce44ea9beec3803807e5ab744723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type.  <a href="#acc3cce44ea9beec3803807e5ab744723">More...</a><br /></td></tr>
<tr class="separator:acc3cce44ea9beec3803807e5ab744723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9cc727418b2f03e3dde312fe720902"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#acd9cc727418b2f03e3dde312fe720902">getFloatArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:acd9cc727418b2f03e3dde312fe720902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in float array type out param.  <a href="#acd9cc727418b2f03e3dde312fe720902">More...</a><br /></td></tr>
<tr class="separator:acd9cc727418b2f03e3dde312fe720902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0a989bf09271d9d8c5dca011a50f56"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#afc0a989bf09271d9d8c5dca011a50f56">getFloatField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:afc0a989bf09271d9d8c5dca011a50f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in float type out param.  <a href="#afc0a989bf09271d9d8c5dca011a50f56">More...</a><br /></td></tr>
<tr class="separator:afc0a989bf09271d9d8c5dca011a50f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cbfe0abff9a11ab0dba3a7f2811b76"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#aa7cbfe0abff9a11ab0dba3a7f2811b76">getIntArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:aa7cbfe0abff9a11ab0dba3a7f2811b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in int32_t array type out param.  <a href="#aa7cbfe0abff9a11ab0dba3a7f2811b76">More...</a><br /></td></tr>
<tr class="separator:aa7cbfe0abff9a11ab0dba3a7f2811b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d689517d1c5509fd81793d7e60f8c7"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a29d689517d1c5509fd81793d7e60f8c7">getIntField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a29d689517d1c5509fd81793d7e60f8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in int32_t type out param.  <a href="#a29d689517d1c5509fd81793d7e60f8c7">More...</a><br /></td></tr>
<tr class="separator:a29d689517d1c5509fd81793d7e60f8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf377486f21a985b6f987e094661a5f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a8cf377486f21a985b6f987e094661a5f">getLongArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a8cf377486f21a985b6f987e094661a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in int64_t array type out param.  <a href="#a8cf377486f21a985b6f987e094661a5f">More...</a><br /></td></tr>
<tr class="separator:a8cf377486f21a985b6f987e094661a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048862c6d5c7dffcec5588ddf09abd29"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a048862c6d5c7dffcec5588ddf09abd29">getLongField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a048862c6d5c7dffcec5588ddf09abd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in int64_t type out param.  <a href="#a048862c6d5c7dffcec5588ddf09abd29">More...</a><br /></td></tr>
<tr class="separator:a048862c6d5c7dffcec5588ddf09abd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2fa8400f94e360ccc2b7f2cff7b94"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00771.html">PdxSerializable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a1ff2fa8400f94e360ccc2b7f2cff7b94">getObject</a> ()=0</td></tr>
<tr class="memdesc:a1ff2fa8400f94e360ccc2b7f2cff7b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes and returns the domain object that this instance represents.  <a href="#a1ff2fa8400f94e360ccc2b7f2cff7b94">More...</a><br /></td></tr>
<tr class="separator:a1ff2fa8400f94e360ccc2b7f2cff7b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b4f971f0dda9432cdd3dc3483f9ec"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#ae92b4f971f0dda9432cdd3dc3483f9ec">getShortArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:ae92b4f971f0dda9432cdd3dc3483f9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in int16_t array type out param.  <a href="#ae92b4f971f0dda9432cdd3dc3483f9ec">More...</a><br /></td></tr>
<tr class="separator:ae92b4f971f0dda9432cdd3dc3483f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf05fa56e7128aa8219db633d934e4d5"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#adf05fa56e7128aa8219db633d934e4d5">getShortField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:adf05fa56e7128aa8219db633d934e4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in int16_t type out param.  <a href="#adf05fa56e7128aa8219db633d934e4d5">More...</a><br /></td></tr>
<tr class="separator:adf05fa56e7128aa8219db633d934e4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ad356ea7d96e2fb7dfd180bf5702ec"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a22ad356ea7d96e2fb7dfd180bf5702ec">getStringArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a22ad356ea7d96e2fb7dfd180bf5702ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field as a string array.  <a href="#a22ad356ea7d96e2fb7dfd180bf5702ec">More...</a><br /></td></tr>
<tr class="separator:a22ad356ea7d96e2fb7dfd180bf5702ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eea18635e71b38cfef5caa0834a712b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a6eea18635e71b38cfef5caa0834a712b">getStringField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a6eea18635e71b38cfef5caa0834a712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and sets its value in std::string type out param.  <a href="#a6eea18635e71b38cfef5caa0834a712b">More...</a><br /></td></tr>
<tr class="separator:a6eea18635e71b38cfef5caa0834a712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051726c7e0dfc684cf8141e0ae4c5235"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235">hasField</a> (const std::string &amp;fieldname)=0</td></tr>
<tr class="memdesc:a051726c7e0dfc684cf8141e0ae4c5235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field exists and returns the result.  <a href="#a051726c7e0dfc684cf8141e0ae4c5235">More...</a><br /></td></tr>
<tr class="separator:a051726c7e0dfc684cf8141e0ae4c5235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7cd1603dcb22930cf0c3d32abe4c70"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a5d7cd1603dcb22930cf0c3d32abe4c70">hashcode</a> () const override=0</td></tr>
<tr class="memdesc:a5d7cd1603dcb22930cf0c3d32abe4c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hashcode based on the identity fields of this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#a5d7cd1603dcb22930cf0c3d32abe4c70">More...</a><br /></td></tr>
<tr class="separator:a5d7cd1603dcb22930cf0c3d32abe4c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a9cdd92ccdd12ec2f2f984c64d1791"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#ae7a9cdd92ccdd12ec2f2f984c64d1791">isIdentityField</a> (const std::string &amp;fieldname)=0</td></tr>
<tr class="memdesc:ae7a9cdd92ccdd12ec2f2f984c64d1791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field was <a class="el" href="a00787.html#a4284cab342603084f26e40658ee66819">PdxWriter#markIdentityField</a>marked as an identity field.  <a href="#ae7a9cdd92ccdd12ec2f2f984c64d1791">More...</a><br /></td></tr>
<tr class="separator:ae7a9cdd92ccdd12ec2f2f984c64d1791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147bbc2fa40218981d1e4c9a0eaed512"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a147bbc2fa40218981d1e4c9a0eaed512">objectSize</a> () const override=0</td></tr>
<tr class="separator:a147bbc2fa40218981d1e4c9a0eaed512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00654c7ddd97e35970bac9d8fa92c8b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a00654c7ddd97e35970bac9d8fa92c8b6">operator==</a> (const <a class="el" href="a00339.html">CacheableKey</a> &amp;other) const override=0</td></tr>
<tr class="memdesc:a00654c7ddd97e35970bac9d8fa92c8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="a00339.html" title="Represents a cacheable key.">CacheableKey</a> derived object is equals to this instance.  <a href="#a00654c7ddd97e35970bac9d8fa92c8b6">More...</a><br /></td></tr>
<tr class="separator:a00654c7ddd97e35970bac9d8fa92c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150bcbfaa96659faaa1da67ab9f6c234"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a150bcbfaa96659faaa1da67ab9f6c234">setField</a> (const std::string &amp;fieldName, std::shared_ptr&lt; <a class="el" href="a00863.html">Cacheable</a> &gt; value)=0</td></tr>
<tr class="memdesc:a150bcbfaa96659faaa1da67ab9f6c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a150bcbfaa96659faaa1da67ab9f6c234">More...</a><br /></td></tr>
<tr class="separator:a150bcbfaa96659faaa1da67ab9f6c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931f271c6b2680728d16e7db82881178"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a931f271c6b2680728d16e7db82881178">setField</a> (const std::string &amp;fieldName, bool value)=0</td></tr>
<tr class="memdesc:a931f271c6b2680728d16e7db82881178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a931f271c6b2680728d16e7db82881178">More...</a><br /></td></tr>
<tr class="separator:a931f271c6b2680728d16e7db82881178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae8ea17976ab42fb556436e7bba41f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a8ae8ea17976ab42fb556436e7bba41f0">setField</a> (const std::string &amp;fieldName, signed char value)=0</td></tr>
<tr class="memdesc:a8ae8ea17976ab42fb556436e7bba41f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a8ae8ea17976ab42fb556436e7bba41f0">More...</a><br /></td></tr>
<tr class="separator:a8ae8ea17976ab42fb556436e7bba41f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a90010620a3d3df4ea14832eff4da0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a93a90010620a3d3df4ea14832eff4da0">setField</a> (const std::string &amp;fieldName, unsigned char value)=0</td></tr>
<tr class="memdesc:a93a90010620a3d3df4ea14832eff4da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a93a90010620a3d3df4ea14832eff4da0">More...</a><br /></td></tr>
<tr class="separator:a93a90010620a3d3df4ea14832eff4da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8a4061cff68a986d48cb97a47399f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#acd8a4061cff68a986d48cb97a47399f2">setField</a> (const std::string &amp;fieldName, int16_t value)=0</td></tr>
<tr class="memdesc:acd8a4061cff68a986d48cb97a47399f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#acd8a4061cff68a986d48cb97a47399f2">More...</a><br /></td></tr>
<tr class="separator:acd8a4061cff68a986d48cb97a47399f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35c74af8fbb9625581137a0c1b8834e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#aa35c74af8fbb9625581137a0c1b8834e">setField</a> (const std::string &amp;fieldName, int32_t value)=0</td></tr>
<tr class="memdesc:aa35c74af8fbb9625581137a0c1b8834e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#aa35c74af8fbb9625581137a0c1b8834e">More...</a><br /></td></tr>
<tr class="separator:aa35c74af8fbb9625581137a0c1b8834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424f723701c5c44eb38127002d9f7091"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a424f723701c5c44eb38127002d9f7091">setField</a> (const std::string &amp;fieldName, int64_t value)=0</td></tr>
<tr class="memdesc:a424f723701c5c44eb38127002d9f7091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a424f723701c5c44eb38127002d9f7091">More...</a><br /></td></tr>
<tr class="separator:a424f723701c5c44eb38127002d9f7091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e295432be32e6973976d196767b5d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a00e295432be32e6973976d196767b5d8">setField</a> (const std::string &amp;fieldName, float value)=0</td></tr>
<tr class="memdesc:a00e295432be32e6973976d196767b5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a00e295432be32e6973976d196767b5d8">More...</a><br /></td></tr>
<tr class="separator:a00e295432be32e6973976d196767b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c89b115930619a15fce44e1b9aaac3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#ae7c89b115930619a15fce44e1b9aaac3">setField</a> (const std::string &amp;fieldName, double value)=0</td></tr>
<tr class="memdesc:ae7c89b115930619a15fce44e1b9aaac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ae7c89b115930619a15fce44e1b9aaac3">More...</a><br /></td></tr>
<tr class="separator:ae7c89b115930619a15fce44e1b9aaac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b9f4332491ef72cbdfb0cd23c83d47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a59b9f4332491ef72cbdfb0cd23c83d47">setField</a> (const std::string &amp;fieldName, char16_t value)=0</td></tr>
<tr class="memdesc:a59b9f4332491ef72cbdfb0cd23c83d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a59b9f4332491ef72cbdfb0cd23c83d47">More...</a><br /></td></tr>
<tr class="separator:a59b9f4332491ef72cbdfb0cd23c83d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe84208b3a9fb14add4b2ce7262c19f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#acfe84208b3a9fb14add4b2ce7262c19f">setField</a> (const std::string &amp;fieldName, std::shared_ptr&lt; <a class="el" href="a00327.html">CacheableDate</a> &gt; value)=0</td></tr>
<tr class="memdesc:acfe84208b3a9fb14add4b2ce7262c19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#acfe84208b3a9fb14add4b2ce7262c19f">More...</a><br /></td></tr>
<tr class="separator:acfe84208b3a9fb14add4b2ce7262c19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4047f667fc19306ce3f80d63355d8c93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a4047f667fc19306ce3f80d63355d8c93">setField</a> (const std::string &amp;fieldName, const std::vector&lt; bool &gt; &amp;value)=0</td></tr>
<tr class="memdesc:a4047f667fc19306ce3f80d63355d8c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a4047f667fc19306ce3f80d63355d8c93">More...</a><br /></td></tr>
<tr class="separator:a4047f667fc19306ce3f80d63355d8c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af4fa0a610488c3933f4069d8c1687f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a2af4fa0a610488c3933f4069d8c1687f">setField</a> (const std::string &amp;fieldName, const std::vector&lt; int8_t &gt; &amp;value)=0</td></tr>
<tr class="memdesc:a2af4fa0a610488c3933f4069d8c1687f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a2af4fa0a610488c3933f4069d8c1687f">More...</a><br /></td></tr>
<tr class="separator:a2af4fa0a610488c3933f4069d8c1687f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf531002989787c7d3404cc19e9356e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a4cf531002989787c7d3404cc19e9356e">setField</a> (const std::string &amp;fieldName, const std::vector&lt; int16_t &gt; &amp;value)=0</td></tr>
<tr class="memdesc:a4cf531002989787c7d3404cc19e9356e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a4cf531002989787c7d3404cc19e9356e">More...</a><br /></td></tr>
<tr class="separator:a4cf531002989787c7d3404cc19e9356e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada636812c7c4a53e802110a77a497340"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#ada636812c7c4a53e802110a77a497340">setField</a> (const std::string &amp;fieldName, const std::vector&lt; int32_t &gt; &amp;value)=0</td></tr>
<tr class="memdesc:ada636812c7c4a53e802110a77a497340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ada636812c7c4a53e802110a77a497340">More...</a><br /></td></tr>
<tr class="separator:ada636812c7c4a53e802110a77a497340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3f6a325c2d1c571e6268f90061ccec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#abc3f6a325c2d1c571e6268f90061ccec">setField</a> (const std::string &amp;fieldName, const std::vector&lt; int64_t &gt; &amp;value)=0</td></tr>
<tr class="memdesc:abc3f6a325c2d1c571e6268f90061ccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#abc3f6a325c2d1c571e6268f90061ccec">More...</a><br /></td></tr>
<tr class="separator:abc3f6a325c2d1c571e6268f90061ccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb855fd9b7e9c90b308198c524cdf0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a04bb855fd9b7e9c90b308198c524cdf0">setField</a> (const std::string &amp;fieldName, const std::vector&lt; float &gt; &amp;value)=0</td></tr>
<tr class="memdesc:a04bb855fd9b7e9c90b308198c524cdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a04bb855fd9b7e9c90b308198c524cdf0">More...</a><br /></td></tr>
<tr class="separator:a04bb855fd9b7e9c90b308198c524cdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4f6e6751debffddf1d242932935b04"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#aab4f6e6751debffddf1d242932935b04">setField</a> (const std::string &amp;fieldName, const std::vector&lt; double &gt; &amp;value)=0</td></tr>
<tr class="memdesc:aab4f6e6751debffddf1d242932935b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#aab4f6e6751debffddf1d242932935b04">More...</a><br /></td></tr>
<tr class="separator:aab4f6e6751debffddf1d242932935b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cea1370d2edcbf992576b9947daa37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#ac7cea1370d2edcbf992576b9947daa37">setField</a> (const std::string &amp;fieldName, const std::string &amp;value)=0</td></tr>
<tr class="memdesc:ac7cea1370d2edcbf992576b9947daa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ac7cea1370d2edcbf992576b9947daa37">More...</a><br /></td></tr>
<tr class="separator:ac7cea1370d2edcbf992576b9947daa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e676b4e0d22d9c1d5573b89416d035c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a4e676b4e0d22d9c1d5573b89416d035c">setField</a> (const std::string &amp;fieldName, const std::vector&lt; char16_t &gt; &amp;value)=0</td></tr>
<tr class="memdesc:a4e676b4e0d22d9c1d5573b89416d035c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a4e676b4e0d22d9c1d5573b89416d035c">More...</a><br /></td></tr>
<tr class="separator:a4e676b4e0d22d9c1d5573b89416d035c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808addaf1480516eb5f2ddf8f9e793a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a808addaf1480516eb5f2ddf8f9e793a8">setField</a> (const std::string &amp;fieldName, std::string *value, int32_t length)=0</td></tr>
<tr class="memdesc:a808addaf1480516eb5f2ddf8f9e793a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a808addaf1480516eb5f2ddf8f9e793a8">More...</a><br /></td></tr>
<tr class="separator:a808addaf1480516eb5f2ddf8f9e793a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae403fcfa69faaca4da5107fda4e4727d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#ae403fcfa69faaca4da5107fda4e4727d">setField</a> (const std::string &amp;fieldName, int8_t **value, int32_t arrayLength, int32_t *elementLength)=0</td></tr>
<tr class="memdesc:ae403fcfa69faaca4da5107fda4e4727d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ae403fcfa69faaca4da5107fda4e4727d">More...</a><br /></td></tr>
<tr class="separator:ae403fcfa69faaca4da5107fda4e4727d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc68be01b663c9add28ce1c5ebc233ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#adc68be01b663c9add28ce1c5ebc233ef">setField</a> (const std::string &amp;fieldName, std::shared_ptr&lt; <a class="el" href="a00355.html">CacheableObjectArray</a> &gt; value)=0</td></tr>
<tr class="memdesc:adc68be01b663c9add28ce1c5ebc233ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#adc68be01b663c9add28ce1c5ebc233ef">More...</a><br /></td></tr>
<tr class="separator:adc68be01b663c9add28ce1c5ebc233ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245bb68e028ee085a78bf1759c009f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#aa245bb68e028ee085a78bf1759c009f6">toData</a> (<a class="el" href="a00787.html">PdxWriter</a> &amp;output) const override=0</td></tr>
<tr class="memdesc:aa245bb68e028ee085a78bf1759c009f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize this object in geode PDX format.  <a href="#aa245bb68e028ee085a78bf1759c009f6">More...</a><br /></td></tr>
<tr class="separator:aa245bb68e028ee085a78bf1759c009f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a4f63885e135d281474d09f33023d8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00759.html#a21a4f63885e135d281474d09f33023d8">toString</a> () const override=0</td></tr>
<tr class="memdesc:a21a4f63885e135d281474d09f33023d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out all of the identity fields of this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#a21a4f63885e135d281474d09f33023d8">More...</a><br /></td></tr>
<tr class="separator:a21a4f63885e135d281474d09f33023d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2ea594bc7d294954d925a6ecd2a092"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#aec2ea594bc7d294954d925a6ecd2a092">~WritablePdxInstance</a> ()=default</td></tr>
<tr class="memdesc:aec2ea594bc7d294954d925a6ecd2a092"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#aec2ea594bc7d294954d925a6ecd2a092">More...</a><br /></td></tr>
<tr class="separator:aec2ea594bc7d294954d925a6ecd2a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a562c8827c49b9808ca4a601a48b944b6"><td class="memTemplParams" colspan="2">template&lt;class _T &gt; </td></tr>
<tr class="memitem:a562c8827c49b9808ca4a601a48b944b6"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="a00339.html">CacheableKey</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00339.html#a562c8827c49b9808ca4a601a48b944b6">create</a> (_T value)</td></tr>
<tr class="memdesc:a562c8827c49b9808ca4a601a48b944b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that creates the key type that matches the type of value.  <a href="#a562c8827c49b9808ca4a601a48b944b6">More...</a><br /></td></tr>
<tr class="separator:a562c8827c49b9808ca4a601a48b944b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b42b5b55a798df561f9031e2b4f602"><td class="memTemplParams" colspan="2">template&lt;class _T &gt; </td></tr>
<tr class="memitem:ac6b42b5b55a798df561f9031e2b4f602"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="a00863.html">Serializable</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00863.html#ac6b42b5b55a798df561f9031e2b4f602">create</a> (_T value)</td></tr>
<tr class="memdesc:ac6b42b5b55a798df561f9031e2b4f602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that creates the <a class="el" href="a00863.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a> object that matches the type of value.  <a href="#ac6b42b5b55a798df561f9031e2b4f602">More...</a><br /></td></tr>
<tr class="separator:ac6b42b5b55a798df561f9031e2b4f602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a46801bcd5f8b699cecc399e62cde3d38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00891.html#a46801bcd5f8b699cecc399e62cde3d38">WritablePdxInstance</a> ()=default</td></tr>
<tr class="memdesc:a46801bcd5f8b699cecc399e62cde3d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructors  <a href="#a46801bcd5f8b699cecc399e62cde3d38">More...</a><br /></td></tr>
<tr class="separator:a46801bcd5f8b699cecc399e62cde3d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> is a <a class="el" href="a00759.html">PdxInstance</a> that also supports field modification using the <a class="el" href="a00891.html#a150bcbfaa96659faaa1da67ab9f6c234">setField</a> method. </p>
<p>To get a <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> call <a class="el" href="a00759.html#af8e8a42bfedd76fec24cfff33fbdd93a">PdxInstance#createWriter</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aec2ea594bc7d294954d925a6ecd2a092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2ea594bc7d294954d925a6ecd2a092">&#9670;&nbsp;</a></span>~WritablePdxInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual apache::geode::client::WritablePdxInstance::~WritablePdxInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>

</div>
</div>
<a id="a46801bcd5f8b699cecc399e62cde3d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46801bcd5f8b699cecc399e62cde3d38">&#9670;&nbsp;</a></span>WritablePdxInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">apache::geode::client::WritablePdxInstance::WritablePdxInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructors </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a562c8827c49b9808ca4a601a48b944b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562c8827c49b9808ca4a601a48b944b6">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="a00339.html">CacheableKey</a>&gt; apache::geode::client::CacheableKey::create </td>
          <td>(</td>
          <td class="paramtype">_T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method that creates the key type that matches the type of value. </p>
<p>For user defined derivations of <a class="el" href="a00339.html" title="Represents a cacheable key.">CacheableKey</a>, the method <a class="el" href="a00339.html#a562c8827c49b9808ca4a601a48b944b6" title="Factory method that creates the key type that matches the type of value.">apache::geode::client::CacheableKey::create</a> may be overloaded. </p>

</div>
</div>
<a id="ac6b42b5b55a798df561f9031e2b4f602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b42b5b55a798df561f9031e2b4f602">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="a00863.html">Serializable</a>&gt; apache::geode::client::Serializable::create </td>
          <td>(</td>
          <td class="paramtype">_T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method that creates the <a class="el" href="a00863.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a> object that matches the type of value. </p>
<p>For user defined derivations of <a class="el" href="a00863.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>, the method <a class="el" href="a00863.html#ac6b42b5b55a798df561f9031e2b4f602" title="Factory method that creates the Serializable object that matches the type of value.">apache::geode::client::Serializable::create</a> may be overloaded. </p>

</div>
</div>
<a id="af8e8a42bfedd76fec24cfff33fbdd93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e8a42bfedd76fec24cfff33fbdd93a">&#9670;&nbsp;</a></span>createWriter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00891.html">WritablePdxInstance</a>&gt; apache::geode::client::PdxInstance::createWriter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="a00891.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<p>This call returns a copy of the current field values so modifications made to the returned value will not modify this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="a00891.html">WritablePdxInstance</a> </dd></dl>

</div>
</div>
<a id="aa3e789d8e4da85f4ec586bd16b737001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e789d8e4da85f4ec586bd16b737001">&#9670;&nbsp;</a></span>fromData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::fromData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00767.html">PdxReader</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize this object. </p>
<p>This is an internal method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>to deserialize the PDX object </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00771.html#aa2429785803446f892d6669d7ebab795">apache::geode::client::PdxSerializable</a>.</p>

</div>
</div>
<a id="ad6a96b719b63a9cbc7eb63f2781cae7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a96b719b63a9cbc7eb63f2781cae7d">&#9670;&nbsp;</a></span>getBooleanArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;bool&gt; apache::geode::client::PdxInstance::getBooleanArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in bool array type out param. </p>
<p>bool* type corresponds to the Java boolean[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a14050655be9f0e5d0b98ca8cd58ebe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14050655be9f0e5d0b98ca8cd58ebe7f">&#9670;&nbsp;</a></span>getBooleanField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::getBooleanField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in bool type out param. </p>
<p>bool type corresponds to the Java boolean type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a6a5367cf178da27aecddc44ac48ce595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5367cf178da27aecddc44ac48ce595">&#9670;&nbsp;</a></span>getByteArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int8_t&gt; apache::geode::client::PdxInstance::getByteArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in signed char array type out param. </p>
<p>int8_t* type corresponds to the Java byte[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a48742741670329aba1d48b25964f2789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48742741670329aba1d48b25964f2789">&#9670;&nbsp;</a></span>getByteField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t apache::geode::client::PdxInstance::getByteField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in signed char type out param. </p>
<p>signed char type corresponds to the Java byte type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="ad813be08753e160b30b0353c9cc5cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad813be08753e160b30b0353c9cc5cd0c">&#9670;&nbsp;</a></span>getCacheableDateField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00327.html">CacheableDate</a>&gt; apache::geode::client::PdxInstance::getCacheableDateField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in std::shared_ptr&lt;CacheableDate&gt; type out param. </p>
<p>std::shared_ptr&lt;CacheableDate&gt; type is corresponding to java Java.util.date type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read std::shared_ptr&lt;CacheableDate&gt; type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="affbe4efe8ed166011ff68a76e78ba96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbe4efe8ed166011ff68a76e78ba96c">&#9670;&nbsp;</a></span>getCacheableField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00863.html">Cacheable</a>&gt; apache::geode::client::PdxInstance::getCacheableField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in std::shared_ptr&lt;Cacheable&gt; type out param. </p>
<p>std::shared_ptr&lt;Cacheable&gt; type corresponds to the Java object type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field. For deserialization C++ Native Client requires the domain class to be registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd>
<dd>
<a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a08b598e4b18862e6e6788a6ba24a05d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b598e4b18862e6e6788a6ba24a05d0">&#9670;&nbsp;</a></span>getCacheableObjectArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00355.html">CacheableObjectArray</a>&gt; apache::geode::client::PdxInstance::getCacheableObjectArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in std::shared_ptr&lt;CacheableObjectArray&gt; type out param. </p>
<p>For deserialization C++ Native Client requires the domain class to be registered. std::shared_ptr&lt;CacheableObjectArray&gt; type corresponds to the Java Object[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read. std::shared_ptr&lt;CacheableObjectArray&gt; type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd>
<dd>
<a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="ae9cc4bf08dbaceb3cd8b59b5015b364f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cc4bf08dbaceb3cd8b59b5015b364f">&#9670;&nbsp;</a></span>getCharArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;char16_t&gt; apache::geode::client::PdxInstance::getCharArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in char array type out param. </p>
<p>char16_t* type corresponds to the Java char[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="ad88b879c6497ebea32d09be9a85964d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88b879c6497ebea32d09be9a85964d3">&#9670;&nbsp;</a></span>getCharField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char16_t apache::geode::client::PdxInstance::getCharField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in char type out param. </p>
<p>char type corresponds to the Java char type. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a2912c23ab766cb21e711088dd3b0c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2912c23ab766cb21e711088dd3b0c1fb">&#9670;&nbsp;</a></span>getClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; apache::geode::client::PdxInstance::getClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the full name of the class that this pdx instance represents. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the class that this pdx instance represents. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> typeid is not defined yet, to get classname or if PdxType is not defined for <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00771.html#acb3cecbfb02d3983c04551850ba7b84c">apache::geode::client::PdxSerializable</a>.</p>

</div>
</div>
<a id="a9ba80875c282330e1d20e7846506ec70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba80875c282330e1d20e7846506ec70">&#9670;&nbsp;</a></span>getDoubleArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;double&gt; apache::geode::client::PdxInstance::getDoubleArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in double array type out param. </p>
<p>double* type corresponds to the Java double[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="accdaa0cbd2791e46eb56b34f7d945bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdaa0cbd2791e46eb56b34f7d945bfa">&#9670;&nbsp;</a></span>getDoubleField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double apache::geode::client::PdxInstance::getDoubleField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in double type out param. </p>
<p>double type corresponds to the Java double type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a676bf0537b037822cc335e69068c078a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676bf0537b037822cc335e69068c078a">&#9670;&nbsp;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t ***&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&amp;&#160;</td>
          <td class="paramname"><em>elementLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in array of byte arrays type out param. </p>
<p>int8_t** type corresponds to the Java byte[][] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field to read. </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with array of byte arrays type. </td></tr>
    <tr><td class="paramname">arrayLength</td><td>arrayLength is set to the number of byte arrays. </td></tr>
    <tr><td class="paramname">elementLength</td><td>elementLength is set to individual byte array lengths. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="aef3cb5ba5c09771f1cc30238e54a7c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3cb5ba5c09771f1cc30238e54a7c3d">&#9670;&nbsp;</a></span>getFieldNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00026.html#abb5c1ce32786fe2c0f7793809b103737">CacheableStringArray</a>&gt; apache::geode::client::PdxInstance::getFieldNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an unmodifiable list of the field names on this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>an unmodifiable list of the field names on this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> </dd></dl>

</div>
</div>
<a id="acc3cce44ea9beec3803807e5ab744723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3cce44ea9beec3803807e5ab744723">&#9670;&nbsp;</a></span>getFieldType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PdxFieldTypes apache::geode::client::PdxInstance::getFieldType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type. </p>
<dl class="section see"><dt>See also</dt><dd>PdxInstance::PdxFieldTypes of the field in the pdx instance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the type </dd></dl>
<dl class="section see"><dt>See also</dt><dd>PdxInstance::PdxFieldTypes of the field in the pdx instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> typeid is not defined yet, to get classname or if PdxType is not defined for <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd9cc727418b2f03e3dde312fe720902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9cc727418b2f03e3dde312fe720902">&#9670;&nbsp;</a></span>getFloatArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;float&gt; apache::geode::client::PdxInstance::getFloatArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in float array type out param. </p>
<p>float* type corresponds to the Java float[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="afc0a989bf09271d9d8c5dca011a50f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0a989bf09271d9d8c5dca011a50f56">&#9670;&nbsp;</a></span>getFloatField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float apache::geode::client::PdxInstance::getFloatField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in float type out param. </p>
<p>float type corresponds to the Java float type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="aa7cbfe0abff9a11ab0dba3a7f2811b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cbfe0abff9a11ab0dba3a7f2811b76">&#9670;&nbsp;</a></span>getIntArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int32_t&gt; apache::geode::client::PdxInstance::getIntArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in int32_t array type out param. </p>
<p>int32_t* type corresponds to the Java int[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a29d689517d1c5509fd81793d7e60f8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d689517d1c5509fd81793d7e60f8c7">&#9670;&nbsp;</a></span>getIntField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::PdxInstance::getIntField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in int32_t type out param. </p>
<p>int32_t type corresponds to the Java int type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cf377486f21a985b6f987e094661a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf377486f21a985b6f987e094661a5f">&#9670;&nbsp;</a></span>getLongArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int64_t&gt; apache::geode::client::PdxInstance::getLongArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in int64_t array type out param. </p>
<p>int64_t* type corresponds to the Java long[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a048862c6d5c7dffcec5588ddf09abd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048862c6d5c7dffcec5588ddf09abd29">&#9670;&nbsp;</a></span>getLongField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t apache::geode::client::PdxInstance::getLongField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in int64_t type out param. </p>
<p>int64_t type corresponds to the Java long type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a1ff2fa8400f94e360ccc2b7f2cff7b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff2fa8400f94e360ccc2b7f2cff7b94">&#9670;&nbsp;</a></span>getObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00771.html">PdxSerializable</a>&gt; apache::geode::client::PdxInstance::getObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes and returns the domain object that this instance represents. </p>
<p>For deserialization C++ Native Client requires the domain class to be registered. </p><dl class="section return"><dt>Returns</dt><dd>the deserialized domain object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

</div>
</div>
<a id="ae92b4f971f0dda9432cdd3dc3483f9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92b4f971f0dda9432cdd3dc3483f9ec">&#9670;&nbsp;</a></span>getShortArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int16_t&gt; apache::geode::client::PdxInstance::getShortArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in int16_t array type out param. </p>
<p>int16_t* type corresponds to the Java short[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="adf05fa56e7128aa8219db633d934e4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf05fa56e7128aa8219db633d934e4d5">&#9670;&nbsp;</a></span>getShortField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t apache::geode::client::PdxInstance::getShortField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in int16_t type out param. </p>
<p>int16_t type corresponds to the Java short type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a22ad356ea7d96e2fb7dfd180bf5702ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ad356ea7d96e2fb7dfd180bf5702ec">&#9670;&nbsp;</a></span>getStringArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; apache::geode::client::PdxInstance::getStringArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field as a string array. </p>
<p>std::vector&lt;std::string&gt; type corresponds to the Java String[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a6eea18635e71b38cfef5caa0834a712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eea18635e71b38cfef5caa0834a712b">&#9670;&nbsp;</a></span>getStringField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string apache::geode::client::PdxInstance::getStringField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and sets its value in std::string type out param. </p>
<p>std::string type corresponds to the Java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string value for field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't have the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00759.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a051726c7e0dfc684cf8141e0ae4c5235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051726c7e0dfc684cf8141e0ae4c5235">&#9670;&nbsp;</a></span>hasField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::hasField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field exists and returns the result. </p>
<p>This can be useful when writing code that handles more than one version of a PDX class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a5d7cd1603dcb22930cf0c3d32abe4c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7cd1603dcb22930cf0c3d32abe4c70">&#9670;&nbsp;</a></span>hashcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::PdxInstance::hashcode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a hashcode based on the identity fields of this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<p>If a <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> has marked identity fields using {<a class="el" href="a00787.html#a4284cab342603084f26e40658ee66819">} then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. </a> For deserialization C++ Native Client requires the domain class to be registered. If the field is an array then all array elements are used for hashcode computation. Otherwise the raw bytes of its value are used to compute the hash code. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the field contains an element that is not of <a class="el" href="a00339.html" title="Represents a cacheable key.">CacheableKey</a> derived type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

<p>Implements <a class="el" href="a00339.html#aff9da784fe4916ea44340e247e0a0bb3">apache::geode::client::CacheableKey</a>.</p>

</div>
</div>
<a id="ae7a9cdd92ccdd12ec2f2f984c64d1791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9cdd92ccdd12ec2f2f984c64d1791">&#9670;&nbsp;</a></span>isIdentityField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::isIdentityField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field was <a class="el" href="a00787.html#a4284cab342603084f26e40658ee66819">PdxWriter#markIdentityField</a>marked as an identity field. </p>
<p>Note that if no fields have been marked then all the fields are used as identity fields even though this method will return <code>false</code> since none of them have been <em>marked</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a147bbc2fa40218981d1e4c9a0eaed512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147bbc2fa40218981d1e4c9a0eaed512">&#9670;&nbsp;</a></span>objectSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t apache::geode::client::PdxInstance::objectSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the object in bytes This is an internal method. It is used in case of heap LRU property is set. </dd></dl>

<p>Reimplemented from <a class="el" href="a00863.html#aa1e74dde03eb0d3fb17752bfdcd347ef">apache::geode::client::Serializable</a>.</p>

</div>
</div>
<a id="a00654c7ddd97e35970bac9d8fa92c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00654c7ddd97e35970bac9d8fa92c8b6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00339.html">CacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="a00339.html" title="Represents a cacheable key.">CacheableKey</a> derived object is equals to this instance. </p>
<p>If <code>other</code> is not a <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> then it is not equal to this instance. NOTE: Even if <code>other</code> is the result of calling {<a class="el" href="a00759.html#a1ff2fa8400f94e360ccc2b7f2cff7b94">} it will not be equal to this instance</a>. </p>
<p>Otherwise equality of two PdxInstances is determined as follows: </p><ol>
<li>
The domain class name must be equal for both PdxInstances </li>
<li>
Each identity field must be equal. </li>
</ol>
<p>If one of the instances does not have a field that the other one does then equals will assume it has the field with a default value. If a <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> has marked identity fields using {<a class="el" href="a00787.html#a4284cab342603084f26e40658ee66819">markIdentityField} then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. </a>An identity field is equal if all the following are true: </p><ol>
<li>
The field name is equal. </li>
<li>
The field type is equal. </li>
<li>
The field value is equal. </li>
</ol>
<p>If an identity field is of type derived from <code>Cacheable</code> then it is deserialized. For deserialization C++ Native Client requires the domain class to be registered. If the deserialized object is an array then all array elements are used to determine equality. If an identity field is of type <code><a class="el" href="a00355.html" title="Implements an immutable Vector of Cacheable objects that can serve as a distributable object for cach...">CacheableObjectArray</a></code> then it is deserialized and all array elements are used to determine equality. For all other field types the value does not need to be deserialized. Instead the serialized raw bytes are compared and used to determine equality. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other instance to compare to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this instance is equal to <code>other</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the field contains an element that is not of <a class="el" href="a00339.html" title="Represents a cacheable key.">CacheableKey</a> derived type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

<p>Implements <a class="el" href="a00339.html#a508b0eef9d80aeda9edf877880c0705f">apache::geode::client::CacheableKey</a>.</p>

</div>
</div>
<a id="a150bcbfaa96659faaa1da67ab9f6c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150bcbfaa96659faaa1da67ab9f6c234">&#9670;&nbsp;</a></span>setField() <span class="overload">[1/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a00863.html">Cacheable</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. std::shared_ptr&lt;Cacheable&gt; type is corresponding to java object type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type std::shared_ptr&lt;Cacheable&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a931f271c6b2680728d16e7db82881178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931f271c6b2680728d16e7db82881178">&#9670;&nbsp;</a></span>setField() <span class="overload">[2/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. bool type is corresponding to java boolean type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ae8ea17976ab42fb556436e7bba41f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae8ea17976ab42fb556436e7bba41f0">&#9670;&nbsp;</a></span>setField() <span class="overload">[3/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. signed char type is corresponding to java byte type. For C++ on Windows and Linux, signed char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to signed char. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type signed char </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93a90010620a3d3df4ea14832eff4da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a90010620a3d3df4ea14832eff4da0">&#9670;&nbsp;</a></span>setField() <span class="overload">[4/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. unsigned char type is corresponding to java byte type. For C++ on Windows and Linux, unsigned char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to unsigned char. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type unsigned char </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd8a4061cff68a986d48cb97a47399f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8a4061cff68a986d48cb97a47399f2">&#9670;&nbsp;</a></span>setField() <span class="overload">[5/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int16_t type is corresponding to java short type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int16_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa35c74af8fbb9625581137a0c1b8834e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35c74af8fbb9625581137a0c1b8834e">&#9670;&nbsp;</a></span>setField() <span class="overload">[6/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int32_t type is corresponding to java int type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a424f723701c5c44eb38127002d9f7091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424f723701c5c44eb38127002d9f7091">&#9670;&nbsp;</a></span>setField() <span class="overload">[7/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int64_t type is corresponding to java long type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00e295432be32e6973976d196767b5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e295432be32e6973976d196767b5d8">&#9670;&nbsp;</a></span>setField() <span class="overload">[8/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. float type is corresponding to java float type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type float </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7c89b115930619a15fce44e1b9aaac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c89b115930619a15fce44e1b9aaac3">&#9670;&nbsp;</a></span>setField() <span class="overload">[9/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. double type is corresponding to java double type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type double </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b9f4332491ef72cbdfb0cd23c83d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b9f4332491ef72cbdfb0cd23c83d47">&#9670;&nbsp;</a></span>setField() <span class="overload">[10/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char type is corresponding to java char type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfe84208b3a9fb14add4b2ce7262c19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe84208b3a9fb14add4b2ce7262c19f">&#9670;&nbsp;</a></span>setField() <span class="overload">[11/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a00327.html">CacheableDate</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. std::shared_ptr&lt;CacheableDate&gt; type is corresponding to java Java.util.date type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type std::shared_ptr&lt;CacheableDate&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4047f667fc19306ce3f80d63355d8c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4047f667fc19306ce3f80d63355d8c93">&#9670;&nbsp;</a></span>setField() <span class="overload">[12/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. bool* type is corresponding to java boolean[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type bool array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2af4fa0a610488c3933f4069d8c1687f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af4fa0a610488c3933f4069d8c1687f">&#9670;&nbsp;</a></span>setField() <span class="overload">[13/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int8_t* type is corresponding to java byte[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int8_t array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cf531002989787c7d3404cc19e9356e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf531002989787c7d3404cc19e9356e">&#9670;&nbsp;</a></span>setField() <span class="overload">[14/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int16_t* type is corresponding to java short[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int16_t array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada636812c7c4a53e802110a77a497340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada636812c7c4a53e802110a77a497340">&#9670;&nbsp;</a></span>setField() <span class="overload">[15/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int32_t* type is corresponding to java int[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int32_t array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc3f6a325c2d1c571e6268f90061ccec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3f6a325c2d1c571e6268f90061ccec">&#9670;&nbsp;</a></span>setField() <span class="overload">[16/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int64_t* type is corresponding to java long[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int64_t array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04bb855fd9b7e9c90b308198c524cdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bb855fd9b7e9c90b308198c524cdf0">&#9670;&nbsp;</a></span>setField() <span class="overload">[17/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. float* type is corresponding to java float[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type float array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab4f6e6751debffddf1d242932935b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4f6e6751debffddf1d242932935b04">&#9670;&nbsp;</a></span>setField() <span class="overload">[18/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. double* type is corresponding to java double[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type double array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7cea1370d2edcbf992576b9947daa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cea1370d2edcbf992576b9947daa37">&#9670;&nbsp;</a></span>setField() <span class="overload">[19/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char* type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char* </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e676b4e0d22d9c1d5573b89416d035c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e676b4e0d22d9c1d5573b89416d035c">&#9670;&nbsp;</a></span>setField() <span class="overload">[20/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char16_t* type is corresponding to java char[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char16_t array </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a808addaf1480516eb5f2ddf8f9e793a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808addaf1480516eb5f2ddf8f9e793a8">&#9670;&nbsp;</a></span>setField() <span class="overload">[21/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char** type is corresponding to java String[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char* array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in CString array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae403fcfa69faaca4da5107fda4e4727d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae403fcfa69faaca4da5107fda4e4727d">&#9670;&nbsp;</a></span>setField() <span class="overload">[22/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>elementLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int8_t** type is corresponding to java byte[][] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type array of byte arrays </td></tr>
    <tr><td class="paramname">arrayLength</td><td>The number of byte arrays. </td></tr>
    <tr><td class="paramname">elementLength</td><td>The lengths of individual byte arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc68be01b663c9add28ce1c5ebc233ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc68be01b663c9add28ce1c5ebc233ef">&#9670;&nbsp;</a></span>setField() <span class="overload">[23/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a00355.html">CacheableObjectArray</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00891.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method.">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. std::shared_ptr&lt;CacheableObjectArray&gt; type is corresponding to java Object[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type std::shared_ptr&lt;CacheableObjectArray&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00475.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa245bb68e028ee085a78bf1759c009f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245bb68e028ee085a78bf1759c009f6">&#9670;&nbsp;</a></span>toData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::toData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00787.html">PdxWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialize this object in geode PDX format. </p>
<p>This is an internal method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>to serialize the PDX object </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00771.html#a28894ac9e842832bcb336915ae3983e0">apache::geode::client::PdxSerializable</a>.</p>

</div>
</div>
<a id="a21a4f63885e135d281474d09f33023d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a4f63885e135d281474d09f33023d8">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string apache::geode::client::PdxInstance::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints out all of the identity fields of this <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<p>If a <a class="el" href="a00759.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> has marked identity fields using {<a class="el" href="a00787.html#a4284cab342603084f26e40658ee66819">} then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields</a>. For deserialization C++ Native Client requires the domain class to be registered.</p>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

<p>Reimplemented from <a class="el" href="a00863.html#ac7a8d506b1a6f8313302b5efd0990378">apache::geode::client::Serializable</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<HR><address style="align: right;"><small>Apache Geode C++ Cache API Documentation</small></address>
