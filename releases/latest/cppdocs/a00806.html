<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Geode Native C++ Reference: apache::geode::client::Region Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Geode Native C++ Reference
   &#160;<span id="projectnumber">1.10.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00806.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">apache::geode::client::Region Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class manages subregions and cached data.  
 <a href="a00806.html#details">More...</a></p>

<p>Inherits enable_shared_from_this&lt; Region &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3ef861ca25d90fcbbbf0b08049ba5944"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a3ef861ca25d90fcbbbf0b08049ba5944">clear</a> (const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a3ef861ca25d90fcbbbf0b08049ba5944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process.  <a href="#a3ef861ca25d90fcbbbf0b08049ba5944">More...</a><br /></td></tr>
<tr class="separator:a3ef861ca25d90fcbbbf0b08049ba5944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eacb47a69159ce022c8f9fbc300f61e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a6eacb47a69159ce022c8f9fbc300f61e">containsKey</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;keyPtr) const =0</td></tr>
<tr class="memdesc:a6eacb47a69159ce022c8f9fbc300f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only the client's cache is searched for the key.  <a href="#a6eacb47a69159ce022c8f9fbc300f61e">More...</a><br /></td></tr>
<tr class="separator:a6eacb47a69159ce022c8f9fbc300f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f28c47f8590e9e776ceaed38783008d"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a5f28c47f8590e9e776ceaed38783008d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a5f28c47f8590e9e776ceaed38783008d">containsKey</a> (const KEYTYPE &amp;key) const</td></tr>
<tr class="memdesc:a5f28c47f8590e9e776ceaed38783008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char* This operations checks for the key in the local cache .  <a href="#a5f28c47f8590e9e776ceaed38783008d">More...</a><br /></td></tr>
<tr class="separator:a5f28c47f8590e9e776ceaed38783008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faf7d74dce69c1f0c2adf5e7570290e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a0faf7d74dce69c1f0c2adf5e7570290e">containsKeyOnServer</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;keyPtr) const =0</td></tr>
<tr class="memdesc:a0faf7d74dce69c1f0c2adf5e7570290e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cache of the server, to which it is connected with, is searched for the key to see if the key is present.  <a href="#a0faf7d74dce69c1f0c2adf5e7570290e">More...</a><br /></td></tr>
<tr class="separator:a0faf7d74dce69c1f0c2adf5e7570290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09436efe7a35f65584b562646e90ea6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#af09436efe7a35f65584b562646e90ea6">containsValueForKey</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;keyPtr) const =0</td></tr>
<tr class="memdesc:af09436efe7a35f65584b562646e90ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operations checks for the value in the local cache .  <a href="#af09436efe7a35f65584b562646e90ea6">More...</a><br /></td></tr>
<tr class="separator:af09436efe7a35f65584b562646e90ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b2ea26884bf10cc79f57c461974b63"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a60b2ea26884bf10cc79f57c461974b63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a60b2ea26884bf10cc79f57c461974b63">containsValueForKey</a> (const KEYTYPE &amp;key) const</td></tr>
<tr class="memdesc:a60b2ea26884bf10cc79f57c461974b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char* This operations checks for the value in the local cache .  <a href="#a60b2ea26884bf10cc79f57c461974b63">More...</a><br /></td></tr>
<tr class="separator:a60b2ea26884bf10cc79f57c461974b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8929dcdb782d03cfc85fdeb8c2124d40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a8929dcdb782d03cfc85fdeb8c2124d40">create</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a8929dcdb782d03cfc85fdeb8c2124d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new entry in this region with the specified key and value, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a8929dcdb782d03cfc85fdeb8c2124d40">More...</a><br /></td></tr>
<tr class="separator:a8929dcdb782d03cfc85fdeb8c2124d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f73f601b6b71f170eb0bdf14893af70"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a5f73f601b6b71f170eb0bdf14893af70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a5f73f601b6b71f170eb0bdf14893af70">create</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a5f73f601b6b71f170eb0bdf14893af70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a5f73f601b6b71f170eb0bdf14893af70">More...</a><br /></td></tr>
<tr class="separator:a5f73f601b6b71f170eb0bdf14893af70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ea14cc5de4f7b866a9d67ecd6fb958"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:ad3ea14cc5de4f7b866a9d67ecd6fb958"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#ad3ea14cc5de4f7b866a9d67ecd6fb958">create</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:ad3ea14cc5de4f7b866a9d67ecd6fb958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#ad3ea14cc5de4f7b866a9d67ecd6fb958">More...</a><br /></td></tr>
<tr class="separator:ad3ea14cc5de4f7b866a9d67ecd6fb958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc2f87e72489bd00bb3b84003aa6395"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:a6dc2f87e72489bd00bb3b84003aa6395"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a6dc2f87e72489bd00bb3b84003aa6395">create</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a6dc2f87e72489bd00bb3b84003aa6395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#a6dc2f87e72489bd00bb3b84003aa6395">More...</a><br /></td></tr>
<tr class="separator:a6dc2f87e72489bd00bb3b84003aa6395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f31ce8a0fa5482138b61e943499e197"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00806.html">Region</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a4f31ce8a0fa5482138b61e943499e197">createSubregion</a> (const std::string &amp;subregionName, <a class="el" href="a00810.html">RegionAttributes</a> aRegionAttributes)=0</td></tr>
<tr class="memdesc:a4f31ce8a0fa5482138b61e943499e197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a subregion with the specified attributes.  <a href="#a4f31ce8a0fa5482138b61e943499e197">More...</a><br /></td></tr>
<tr class="separator:a4f31ce8a0fa5482138b61e943499e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1330d8868efec3be5caa7bd04ce8f622"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622">destroy</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a1330d8868efec3be5caa7bd04ce8f622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the entry with the specified key, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a1330d8868efec3be5caa7bd04ce8f622">More...</a><br /></td></tr>
<tr class="separator:a1330d8868efec3be5caa7bd04ce8f622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b785d71a099118536f4ab685325d302"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a2b785d71a099118536f4ab685325d302"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a2b785d71a099118536f4ab685325d302">destroy</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a2b785d71a099118536f4ab685325d302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a2b785d71a099118536f4ab685325d302">More...</a><br /></td></tr>
<tr class="separator:a2b785d71a099118536f4ab685325d302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e00376744c98bc9d2db341a865c69a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a0e00376744c98bc9d2db341a865c69a3">destroyRegion</a> (const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a0e00376744c98bc9d2db341a865c69a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a0e00376744c98bc9d2db341a865c69a3">More...</a><br /></td></tr>
<tr class="separator:a0e00376744c98bc9d2db341a865c69a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a367e94055c973a046148b0c9c98bff"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a3a367e94055c973a046148b0c9c98bff">existsValue</a> (const std::string &amp;predicate, std::chrono::milliseconds timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0</td></tr>
<tr class="memdesc:a3a367e94055c973a046148b0c9c98bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the query on the server based on the predicate and returns whether any result exists.  <a href="#a3a367e94055c973a046148b0c9c98bff">More...</a><br /></td></tr>
<tr class="separator:a3a367e94055c973a046148b0c9c98bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4423292be4f114db87bc14bcf026a9f7"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a4423292be4f114db87bc14bcf026a9f7">get</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a4423292be4f114db87bc14bcf026a9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value associated with the specified key, passing the callback argument to any cache loaders that are invoked in the operation.  <a href="#a4423292be4f114db87bc14bcf026a9f7">More...</a><br /></td></tr>
<tr class="separator:a4423292be4f114db87bc14bcf026a9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75d99d826c24cfe3b516f965790a1a"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a5f75d99d826c24cfe3b516f965790a1a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a5f75d99d826c24cfe3b516f965790a1a">get</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;callbackArg=nullptr)</td></tr>
<tr class="memdesc:a5f75d99d826c24cfe3b516f965790a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a5f75d99d826c24cfe3b516f965790a1a">More...</a><br /></td></tr>
<tr class="separator:a5f75d99d826c24cfe3b516f965790a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cd6bbcccae9c07a813f4f38b1977a7"><td class="memItemLeft" align="right" valign="top">virtual HashMapOfCacheable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ae9cd6bbcccae9c07a813f4f38b1977a7">getAll</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;<a class="el" href="a00806.html#a9bd81fa0496c7857e8002857adc5222b">keys</a>, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:ae9cd6bbcccae9c07a813f4f38b1977a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets values for an array of keys from the local cache or server.  <a href="#ae9cd6bbcccae9c07a813f4f38b1977a7">More...</a><br /></td></tr>
<tr class="separator:ae9cd6bbcccae9c07a813f4f38b1977a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cc9292b643aa332f13c79c24c5dbb6"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="a00810.html">RegionAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ac2cc9292b643aa332f13c79c24c5dbb6">getAttributes</a> () const =0</td></tr>
<tr class="memdesc:ac2cc9292b643aa332f13c79c24c5dbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="a00810.html" title="Defines attributes for configuring a region.">RegionAttributes</a> for this region.  <a href="#ac2cc9292b643aa332f13c79c24c5dbb6">More...</a><br /></td></tr>
<tr class="separator:ac2cc9292b643aa332f13c79c24c5dbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adce4f4840cd90bcddeee212f818b65"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00274.html">AttributesMutator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a2adce4f4840cd90bcddeee212f818b65">getAttributesMutator</a> () const =0</td></tr>
<tr class="memdesc:a2adce4f4840cd90bcddeee212f818b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the a mutator object for changing a subset of the region attributes.  <a href="#a2adce4f4840cd90bcddeee212f818b65">More...</a><br /></td></tr>
<tr class="separator:a2adce4f4840cd90bcddeee212f818b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df8721137a736b7beb58829d3be167f"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00818.html">RegionEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a1df8721137a736b7beb58829d3be167f">getEntry</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key)=0</td></tr>
<tr class="memdesc:a1df8721137a736b7beb58829d3be167f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the meta-object <a class="el" href="a00818.html" title="An object in a Region that represents an entry, i.e., a key-value pair.">RegionEntry</a> for key.  <a href="#a1df8721137a736b7beb58829d3be167f">More...</a><br /></td></tr>
<tr class="separator:a1df8721137a736b7beb58829d3be167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8540a02a3d036f8212c1c9556bd9959e"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a8540a02a3d036f8212c1c9556bd9959e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a00818.html">RegionEntry</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a8540a02a3d036f8212c1c9556bd9959e">getEntry</a> (const KEYTYPE &amp;key)</td></tr>
<tr class="memdesc:a8540a02a3d036f8212c1c9556bd9959e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a8540a02a3d036f8212c1c9556bd9959e">More...</a><br /></td></tr>
<tr class="separator:a8540a02a3d036f8212c1c9556bd9959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121f22e1598bee66ea6106d6359c61de"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a121f22e1598bee66ea6106d6359c61de">getFullPath</a> () const =0</td></tr>
<tr class="memdesc:a121f22e1598bee66ea6106d6359c61de"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the full path of the region as can be used to lookup the region from <a class="el" href="a00286.html#af80a5d73de38233b22e409fe55c51a00" title="Look up a region with the full path from root.">Cache::getRegion</a>.  <a href="#a121f22e1598bee66ea6106d6359c61de">More...</a><br /></td></tr>
<tr class="separator:a121f22e1598bee66ea6106d6359c61de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace982eee9216ad3fdec5da966fb1f1ba"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ace982eee9216ad3fdec5da966fb1f1ba">getInterestList</a> () const =0</td></tr>
<tr class="memdesc:ace982eee9216ad3fdec5da966fb1f1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of keys on which this client is interested and will be notified of changes.  <a href="#ace982eee9216ad3fdec5da966fb1f1ba">More...</a><br /></td></tr>
<tr class="separator:ace982eee9216ad3fdec5da966fb1f1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ca0d0be77447b032d8e605c742db03"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00358.html">CacheableString</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ad4ca0d0be77447b032d8e605c742db03">getInterestListRegex</a> () const =0</td></tr>
<tr class="memdesc:ad4ca0d0be77447b032d8e605c742db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of regular expresssions on which this client is interested and will be notified of changes.  <a href="#ad4ca0d0be77447b032d8e605c742db03">More...</a><br /></td></tr>
<tr class="separator:ad4ca0d0be77447b032d8e605c742db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b892f9946cd913d961e50367edc7f"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#add7b892f9946cd913d961e50367edc7f">getName</a> () const =0</td></tr>
<tr class="memdesc:add7b892f9946cd913d961e50367edc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public Methods.  <a href="#add7b892f9946cd913d961e50367edc7f">More...</a><br /></td></tr>
<tr class="separator:add7b892f9946cd913d961e50367edc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a581207a44891db2a6df2e65e4e9a2c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00806.html">Region</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a9a581207a44891db2a6df2e65e4e9a2c">getParentRegion</a> () const =0</td></tr>
<tr class="memdesc:a9a581207a44891db2a6df2e65e4e9a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent region, or nullptr if a root region.  <a href="#a9a581207a44891db2a6df2e65e4e9a2c">More...</a><br /></td></tr>
<tr class="separator:a9a581207a44891db2a6df2e65e4e9a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac235fcbacdc1d6db5fb616aafd3f57aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00830.html">RegionService</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ac235fcbacdc1d6db5fb616aafd3f57aa">getRegionService</a> () const =0</td></tr>
<tr class="memdesc:ac235fcbacdc1d6db5fb616aafd3f57aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>cache</code> associated with this region.  <a href="#ac235fcbacdc1d6db5fb616aafd3f57aa">More...</a><br /></td></tr>
<tr class="separator:ac235fcbacdc1d6db5fb616aafd3f57aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34809291097fec7446b80a004a7ed692"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00806.html">Region</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a34809291097fec7446b80a004a7ed692">getSubregion</a> (const std::string &amp;path)=0</td></tr>
<tr class="memdesc:a34809291097fec7446b80a004a7ed692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the subregion identified by the path, nullptr if no such subregion.  <a href="#a34809291097fec7446b80a004a7ed692">More...</a><br /></td></tr>
<tr class="separator:a34809291097fec7446b80a004a7ed692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5d2224d28bb3ec4647138c93d17bf3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#aaf5d2224d28bb3ec4647138c93d17bf3">invalidate</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:aaf5d2224d28bb3ec4647138c93d17bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the entry with the specified key, and provides a user-defined argument to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>.  <a href="#aaf5d2224d28bb3ec4647138c93d17bf3">More...</a><br /></td></tr>
<tr class="separator:aaf5d2224d28bb3ec4647138c93d17bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1016552d35db8e66fbc5ff9677fd81"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a8b1016552d35db8e66fbc5ff9677fd81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a8b1016552d35db8e66fbc5ff9677fd81">invalidate</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a8b1016552d35db8e66fbc5ff9677fd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a8b1016552d35db8e66fbc5ff9677fd81">More...</a><br /></td></tr>
<tr class="separator:a8b1016552d35db8e66fbc5ff9677fd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8c7859dda52ac8d4c8400181a9b255"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a7b8c7859dda52ac8d4c8400181a9b255">invalidateRegion</a> (const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a7b8c7859dda52ac8d4c8400181a9b255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates this region.  <a href="#a7b8c7859dda52ac8d4c8400181a9b255">More...</a><br /></td></tr>
<tr class="separator:a7b8c7859dda52ac8d4c8400181a9b255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd81fa0496c7857e8002857adc5222b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a9bd81fa0496c7857e8002857adc5222b">keys</a> ()=0</td></tr>
<tr class="memdesc:a9bd81fa0496c7857e8002857adc5222b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all the keys in the local process for this region.  <a href="#a9bd81fa0496c7857e8002857adc5222b">More...</a><br /></td></tr>
<tr class="separator:a9bd81fa0496c7857e8002857adc5222b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad98b833f6a7fa2f523e4f9c48e156c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a3ad98b833f6a7fa2f523e4f9c48e156c">localClear</a> (const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a3ad98b833f6a7fa2f523e4f9c48e156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process.  <a href="#a3ad98b833f6a7fa2f523e4f9c48e156c">More...</a><br /></td></tr>
<tr class="separator:a3ad98b833f6a7fa2f523e4f9c48e156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d53cf0407f8ffbcd469cb8184d992a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ab7d53cf0407f8ffbcd469cb8184d992a">localCreate</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:ab7d53cf0407f8ffbcd469cb8184d992a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new entry in this region with the specified key and value in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#ab7d53cf0407f8ffbcd469cb8184d992a">More...</a><br /></td></tr>
<tr class="separator:ab7d53cf0407f8ffbcd469cb8184d992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d5df0f3da39624e8b91374c4d0cc4d"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a12d5df0f3da39624e8b91374c4d0cc4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a12d5df0f3da39624e8b91374c4d0cc4d">localCreate</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a12d5df0f3da39624e8b91374c4d0cc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a12d5df0f3da39624e8b91374c4d0cc4d">More...</a><br /></td></tr>
<tr class="separator:a12d5df0f3da39624e8b91374c4d0cc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803c712c4b8fb815312ba65c35f8f638"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a803c712c4b8fb815312ba65c35f8f638"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a803c712c4b8fb815312ba65c35f8f638">localCreate</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a803c712c4b8fb815312ba65c35f8f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a803c712c4b8fb815312ba65c35f8f638">More...</a><br /></td></tr>
<tr class="separator:a803c712c4b8fb815312ba65c35f8f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618ea2e7439a0fc8a49085fc6246cfed"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:a618ea2e7439a0fc8a49085fc6246cfed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a618ea2e7439a0fc8a49085fc6246cfed">localCreate</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a618ea2e7439a0fc8a49085fc6246cfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#a618ea2e7439a0fc8a49085fc6246cfed">More...</a><br /></td></tr>
<tr class="separator:a618ea2e7439a0fc8a49085fc6246cfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15edb6a306b2034de0c0fed001fe77f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ae15edb6a306b2034de0c0fed001fe77f">localDestroy</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:ae15edb6a306b2034de0c0fed001fe77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#ae15edb6a306b2034de0c0fed001fe77f">More...</a><br /></td></tr>
<tr class="separator:ae15edb6a306b2034de0c0fed001fe77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da6a035aa53cd86a0a111160bdfcbbc"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a4da6a035aa53cd86a0a111160bdfcbbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a4da6a035aa53cd86a0a111160bdfcbbc">localDestroy</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a4da6a035aa53cd86a0a111160bdfcbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a4da6a035aa53cd86a0a111160bdfcbbc">More...</a><br /></td></tr>
<tr class="separator:a4da6a035aa53cd86a0a111160bdfcbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7572b61d45c19a28667779c68e44869b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a7572b61d45c19a28667779c68e44869b">localDestroyRegion</a> (const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a7572b61d45c19a28667779c68e44869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a7572b61d45c19a28667779c68e44869b">More...</a><br /></td></tr>
<tr class="separator:a7572b61d45c19a28667779c68e44869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2bad01768d7c54470dc6364fd1d9c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#aec2bad01768d7c54470dc6364fd1d9c1">localInvalidate</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:aec2bad01768d7c54470dc6364fd1d9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the entry with the specified key in the local cache only, and provides a user-defined argument to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>.  <a href="#aec2bad01768d7c54470dc6364fd1d9c1">More...</a><br /></td></tr>
<tr class="separator:aec2bad01768d7c54470dc6364fd1d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dcb92f1d653430aaf87c577eaef4ea"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a26dcb92f1d653430aaf87c577eaef4ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a26dcb92f1d653430aaf87c577eaef4ea">localInvalidate</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a26dcb92f1d653430aaf87c577eaef4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a26dcb92f1d653430aaf87c577eaef4ea">More...</a><br /></td></tr>
<tr class="separator:a26dcb92f1d653430aaf87c577eaef4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2aa318cee5209815bec5dcad3db3c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a8a2aa318cee5209815bec5dcad3db3c3">localInvalidateRegion</a> (const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a8a2aa318cee5209815bec5dcad3db3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates this region.  <a href="#a8a2aa318cee5209815bec5dcad3db3c3">More...</a><br /></td></tr>
<tr class="separator:a8a2aa318cee5209815bec5dcad3db3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b987344899b83ff9e3a786adc2f8ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a56b987344899b83ff9e3a786adc2f8ec">localPut</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a56b987344899b83ff9e3a786adc2f8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a new value into an entry in this region with the specified key in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a56b987344899b83ff9e3a786adc2f8ec">More...</a><br /></td></tr>
<tr class="separator:a56b987344899b83ff9e3a786adc2f8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795a7a96f8d6bf78efe9cfe88dc359e0"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a795a7a96f8d6bf78efe9cfe88dc359e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a795a7a96f8d6bf78efe9cfe88dc359e0">localPut</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a795a7a96f8d6bf78efe9cfe88dc359e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a795a7a96f8d6bf78efe9cfe88dc359e0">More...</a><br /></td></tr>
<tr class="separator:a795a7a96f8d6bf78efe9cfe88dc359e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e88f748827b7492d9e63262b7213fec"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a7e88f748827b7492d9e63262b7213fec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a7e88f748827b7492d9e63262b7213fec">localPut</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a7e88f748827b7492d9e63262b7213fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a7e88f748827b7492d9e63262b7213fec">More...</a><br /></td></tr>
<tr class="separator:a7e88f748827b7492d9e63262b7213fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c0922b4263f6a56f77bf0c400a530d"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:a67c0922b4263f6a56f77bf0c400a530d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a67c0922b4263f6a56f77bf0c400a530d">localPut</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a67c0922b4263f6a56f77bf0c400a530d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#a67c0922b4263f6a56f77bf0c400a530d">More...</a><br /></td></tr>
<tr class="separator:a67c0922b4263f6a56f77bf0c400a530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d81acc0a327cae9fc19501d8cc83e44"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a5d81acc0a327cae9fc19501d8cc83e44">localRemove</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a5d81acc0a327cae9fc19501d8cc83e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key and value in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a5d81acc0a327cae9fc19501d8cc83e44">More...</a><br /></td></tr>
<tr class="separator:a5d81acc0a327cae9fc19501d8cc83e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db734c1ebff0e40b383583aa8b40d0d"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a5db734c1ebff0e40b383583aa8b40d0d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a5db734c1ebff0e40b383583aa8b40d0d">localRemove</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a5db734c1ebff0e40b383583aa8b40d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a5db734c1ebff0e40b383583aa8b40d0d">More...</a><br /></td></tr>
<tr class="separator:a5db734c1ebff0e40b383583aa8b40d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f4f753f6d82d5ff1d16335ca0f6ad6"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:ab4f4f753f6d82d5ff1d16335ca0f6ad6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#ab4f4f753f6d82d5ff1d16335ca0f6ad6">localRemove</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:ab4f4f753f6d82d5ff1d16335ca0f6ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#ab4f4f753f6d82d5ff1d16335ca0f6ad6">More...</a><br /></td></tr>
<tr class="separator:ab4f4f753f6d82d5ff1d16335ca0f6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a334dc5a2eed774d3cfb18dca7588"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:af70a334dc5a2eed774d3cfb18dca7588"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#af70a334dc5a2eed774d3cfb18dca7588">localRemove</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:af70a334dc5a2eed774d3cfb18dca7588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#af70a334dc5a2eed774d3cfb18dca7588">More...</a><br /></td></tr>
<tr class="separator:af70a334dc5a2eed774d3cfb18dca7588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817c35ed57ec56328b77cf56fd854bd3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a817c35ed57ec56328b77cf56fd854bd3">localRemoveEx</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a817c35ed57ec56328b77cf56fd854bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a817c35ed57ec56328b77cf56fd854bd3">More...</a><br /></td></tr>
<tr class="separator:a817c35ed57ec56328b77cf56fd854bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab0f1aaee2012f4078ddef9cbcd0f77"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a5ab0f1aaee2012f4078ddef9cbcd0f77"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a5ab0f1aaee2012f4078ddef9cbcd0f77">localRemoveEx</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a5ab0f1aaee2012f4078ddef9cbcd0f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a5ab0f1aaee2012f4078ddef9cbcd0f77">More...</a><br /></td></tr>
<tr class="separator:a5ab0f1aaee2012f4078ddef9cbcd0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d37f770f04349d9c06799ab2ea4329e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a6d37f770f04349d9c06799ab2ea4329e">put</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a6d37f770f04349d9c06799ab2ea4329e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a new value into an entry in this region with the specified key, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a6d37f770f04349d9c06799ab2ea4329e">More...</a><br /></td></tr>
<tr class="separator:a6d37f770f04349d9c06799ab2ea4329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ced28273734ba50a42b301461fd3192"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a7ced28273734ba50a42b301461fd3192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a7ced28273734ba50a42b301461fd3192">put</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a7ced28273734ba50a42b301461fd3192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a7ced28273734ba50a42b301461fd3192">More...</a><br /></td></tr>
<tr class="separator:a7ced28273734ba50a42b301461fd3192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0037ec09ed1f38ff6d4094110442a"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:aecb0037ec09ed1f38ff6d4094110442a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#aecb0037ec09ed1f38ff6d4094110442a">put</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:aecb0037ec09ed1f38ff6d4094110442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#aecb0037ec09ed1f38ff6d4094110442a">More...</a><br /></td></tr>
<tr class="separator:aecb0037ec09ed1f38ff6d4094110442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69113f479f312a834583d7bde304d532"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:a69113f479f312a834583d7bde304d532"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a69113f479f312a834583d7bde304d532">put</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a69113f479f312a834583d7bde304d532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#a69113f479f312a834583d7bde304d532">More...</a><br /></td></tr>
<tr class="separator:a69113f479f312a834583d7bde304d532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01ef3839d72091410d7261a91a34729"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ad01ef3839d72091410d7261a91a34729">putAll</a> (const HashMapOfCacheable &amp;map, std::chrono::milliseconds timeout=DEFAULT_RESPONSE_TIMEOUT, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:ad01ef3839d72091410d7261a91a34729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a set of new values in this region with the specified keys given as a map of key/value pairs.  <a href="#ad01ef3839d72091410d7261a91a34729">More...</a><br /></td></tr>
<tr class="separator:ad01ef3839d72091410d7261a91a34729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aa2905866218924960c3d4d8336e1f"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00842.html">SelectResults</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a77aa2905866218924960c3d4d8336e1f">query</a> (const std::string &amp;predicate, std::chrono::milliseconds timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0</td></tr>
<tr class="memdesc:a77aa2905866218924960c3d4d8336e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the query on the server based on the predicate.  <a href="#a77aa2905866218924960c3d4d8336e1f">More...</a><br /></td></tr>
<tr class="separator:a77aa2905866218924960c3d4d8336e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831b5bac108bd92dd436ffad49d859c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a831b5bac108bd92dd436ffad49d859c2">registerAllKeys</a> (bool isDurable=false, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>
<tr class="memdesc:a831b5bac108bd92dd436ffad49d859c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers to get updates for all keys from the server.  <a href="#a831b5bac108bd92dd436ffad49d859c2">More...</a><br /></td></tr>
<tr class="separator:a831b5bac108bd92dd436ffad49d859c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9a5fcce916d2e353d0da6c72fb8695"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a5f9a5fcce916d2e353d0da6c72fb8695">registerKeys</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;<a class="el" href="a00806.html#a9bd81fa0496c7857e8002857adc5222b">keys</a>, bool isDurable=false, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>
<tr class="memdesc:a5f9a5fcce916d2e353d0da6c72fb8695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an array of keys for getting updates from the server.  <a href="#a5f9a5fcce916d2e353d0da6c72fb8695">More...</a><br /></td></tr>
<tr class="separator:a5f9a5fcce916d2e353d0da6c72fb8695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2018c44f6006a5d6edf68cdec8ffec0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ac2018c44f6006a5d6edf68cdec8ffec0">registerRegex</a> (const std::string &amp;regex, bool isDurable=false, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>
<tr class="memdesc:ac2018c44f6006a5d6edf68cdec8ffec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a regular expression to match with keys to get updates from the server.  <a href="#ac2018c44f6006a5d6edf68cdec8ffec0">More...</a><br /></td></tr>
<tr class="separator:ac2018c44f6006a5d6edf68cdec8ffec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d7580c858e42f4288ad9035a77e3e6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a93d7580c858e42f4288ad9035a77e3e6">remove</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a93d7580c858e42f4288ad9035a77e3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key, value and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a93d7580c858e42f4288ad9035a77e3e6">More...</a><br /></td></tr>
<tr class="separator:a93d7580c858e42f4288ad9035a77e3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57a717df98aab2ee922d9cb6d1f9ab3"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:ac57a717df98aab2ee922d9cb6d1f9ab3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#ac57a717df98aab2ee922d9cb6d1f9ab3">remove</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:ac57a717df98aab2ee922d9cb6d1f9ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#ac57a717df98aab2ee922d9cb6d1f9ab3">More...</a><br /></td></tr>
<tr class="separator:ac57a717df98aab2ee922d9cb6d1f9ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0389e6ce08e4256e990357b3977dfa"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:ade0389e6ce08e4256e990357b3977dfa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#ade0389e6ce08e4256e990357b3977dfa">remove</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:ade0389e6ce08e4256e990357b3977dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#ade0389e6ce08e4256e990357b3977dfa">More...</a><br /></td></tr>
<tr class="separator:ade0389e6ce08e4256e990357b3977dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2743de0f0decb4b36bfddfa22aaf84"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:a5c2743de0f0decb4b36bfddfa22aaf84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a5c2743de0f0decb4b36bfddfa22aaf84">remove</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const VALUETYPE &amp;value, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a5c2743de0f0decb4b36bfddfa22aaf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#a5c2743de0f0decb4b36bfddfa22aaf84">More...</a><br /></td></tr>
<tr class="separator:a5c2743de0f0decb4b36bfddfa22aaf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e296f91e1f08868cb7b1c76180d37c"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a82e296f91e1f08868cb7b1c76180d37c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a82e296f91e1f08868cb7b1c76180d37c">remove</a> (const KEYTYPE &amp;key)</td></tr>
<tr class="memdesc:a82e296f91e1f08868cb7b1c76180d37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a82e296f91e1f08868cb7b1c76180d37c">More...</a><br /></td></tr>
<tr class="separator:a82e296f91e1f08868cb7b1c76180d37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d35d2cfdcbe1bfcd050d5beb154db8f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a9d35d2cfdcbe1bfcd050d5beb154db8f">removeAll</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;<a class="el" href="a00806.html#a9bd81fa0496c7857e8002857adc5222b">keys</a>, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a9d35d2cfdcbe1bfcd050d5beb154db8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the entries for the specified keys from this region.  <a href="#a9d35d2cfdcbe1bfcd050d5beb154db8f">More...</a><br /></td></tr>
<tr class="separator:a9d35d2cfdcbe1bfcd050d5beb154db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9273d5b4ff2266ddeb298e3b3d186cec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a9273d5b4ff2266ddeb298e3b3d186cec">removeEx</a> (const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;aCallbackArgument=nullptr)=0</td></tr>
<tr class="memdesc:a9273d5b4ff2266ddeb298e3b3d186cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#a9273d5b4ff2266ddeb298e3b3d186cec">More...</a><br /></td></tr>
<tr class="separator:a9273d5b4ff2266ddeb298e3b3d186cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7182d61675e7c19c980f955c301d89b5"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a7182d61675e7c19c980f955c301d89b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00806.html#a7182d61675e7c19c980f955c301d89b5">removeEx</a> (const KEYTYPE &amp;key, const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;arg=nullptr)</td></tr>
<tr class="memdesc:a7182d61675e7c19c980f955c301d89b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a7182d61675e7c19c980f955c301d89b5">More...</a><br /></td></tr>
<tr class="separator:a7182d61675e7c19c980f955c301d89b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3eb9ab90811f9cc4d46d7663626381"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#aec3eb9ab90811f9cc4d46d7663626381">selectValue</a> (const std::string &amp;predicate, std::chrono::milliseconds timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0</td></tr>
<tr class="memdesc:aec3eb9ab90811f9cc4d46d7663626381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the query on the server based on the predicate and returns a single result value.  <a href="#aec3eb9ab90811f9cc4d46d7663626381">More...</a><br /></td></tr>
<tr class="separator:aec3eb9ab90811f9cc4d46d7663626381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1f765d6525702103c2d9d090ff7982"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a4d1f765d6525702103c2d9d090ff7982">serverKeys</a> ()=0</td></tr>
<tr class="memdesc:a4d1f765d6525702103c2d9d090ff7982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of keys defined in the server process associated to this client and region.  <a href="#a4d1f765d6525702103c2d9d090ff7982">More...</a><br /></td></tr>
<tr class="separator:a4d1f765d6525702103c2d9d090ff7982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b37fec3c6097344a89b34e1799018"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#aa01b37fec3c6097344a89b34e1799018">size</a> ()=0</td></tr>
<tr class="memdesc:aa01b37fec3c6097344a89b34e1799018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of region.  <a href="#aa01b37fec3c6097344a89b34e1799018">More...</a><br /></td></tr>
<tr class="separator:aa01b37fec3c6097344a89b34e1799018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66ef3e6ca701076e8328ff17c3f1d09"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00806.html">Region</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#ab66ef3e6ca701076e8328ff17c3f1d09">subregions</a> (const bool recursive)=0</td></tr>
<tr class="memdesc:ab66ef3e6ca701076e8328ff17c3f1d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the passed in std::vector&lt;std::shared_ptr&lt;Region&gt;&gt; with subregions of the current region.  <a href="#ab66ef3e6ca701076e8328ff17c3f1d09">More...</a><br /></td></tr>
<tr class="separator:ab66ef3e6ca701076e8328ff17c3f1d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c32984b1fda64e87f35a4ce29762c72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a2c32984b1fda64e87f35a4ce29762c72">unregisterAllKeys</a> ()=0</td></tr>
<tr class="memdesc:a2c32984b1fda64e87f35a4ce29762c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers to get updates for all keys from the server.  <a href="#a2c32984b1fda64e87f35a4ce29762c72">More...</a><br /></td></tr>
<tr class="separator:a2c32984b1fda64e87f35a4ce29762c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f17fec44de821243e963e49bb7bb410"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#a2f17fec44de821243e963e49bb7bb410">unregisterKeys</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;<a class="el" href="a00806.html#a9bd81fa0496c7857e8002857adc5222b">keys</a>)=0</td></tr>
<tr class="memdesc:a2f17fec44de821243e963e49bb7bb410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an array of keys to stop getting updates for them.  <a href="#a2f17fec44de821243e963e49bb7bb410">More...</a><br /></td></tr>
<tr class="separator:a2f17fec44de821243e963e49bb7bb410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9da5d2aa1728197efc0a0caf43c539"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#aea9da5d2aa1728197efc0a0caf43c539">unregisterRegex</a> (const std::string &amp;regex)=0</td></tr>
<tr class="memdesc:aea9da5d2aa1728197efc0a0caf43c539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a regular expression to stop getting updates for keys from the server.  <a href="#aea9da5d2aa1728197efc0a0caf43c539">More...</a><br /></td></tr>
<tr class="separator:aea9da5d2aa1728197efc0a0caf43c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8edb4375cc9a76336871f1f7c5cd39"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html#aff8edb4375cc9a76336871f1f7c5cd39">values</a> ()=0</td></tr>
<tr class="memdesc:aff8edb4375cc9a76336871f1f7c5cd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all values in the local process for this region.  <a href="#aff8edb4375cc9a76336871f1f7c5cd39">More...</a><br /></td></tr>
<tr class="separator:aff8edb4375cc9a76336871f1f7c5cd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class manages subregions and cached data. </p>
<p>Each region can contain multiple subregions and entries for data. Regions provide a hierachical name space within the cache. Also, a region can be used to group cached objects for management purposes.</p>
<p>Entries managed by the region are key-value pairs. A set of region attributes is associated with the region when it is created.</p>
<p>The <a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a> interface basically contains two set of APIs: <a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a> management APIs and (potentially) distributed operations on entries. Non-distributed operations on entries are provided by <code><a class="el" href="a00818.html" title="An object in a Region that represents an entry, i.e., a key-value pair.">RegionEntry</a></code>.</p>
<p>Each <code><a class="el" href="a00286.html" title="Caches are obtained from the create method on the CacheFactory#create class.">Cache</a></code> defines regions called the root regions. User applications can use the root regions to create subregions for isolated name space and object grouping.</p>
<p>A region's name can be any String, except that it should not contain the region name separator, a forward slash (/).</p>
<p><code>Regions</code> can be referenced by a relative path name from any region higher in the hierarchy in <a class="el" href="a00806.html#a34809291097fec7446b80a004a7ed692">Region::getSubregion</a>. You can get the relative path from the root region with <a class="el" href="a00806.html#a121f22e1598bee66ea6106d6359c61de">Region::getFullPath</a>. The name separator is used to concatenate all the region names together from the root, starting with the root's subregions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00810.html" title="Defines attributes for configuring a region.">RegionAttributes</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ef861ca25d90fcbbbf0b08049ba5944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef861ca25d90fcbbbf0b08049ba5944">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::clear </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00374.html#ae81f5fe95bd0a2ad570a273a4e3ccd2f" title="Handles the event of a region being cleared.">CacheListener::afterRegionClear</a> </dd>
<dd>
<a class="el" href="a00390.html#a1fc3cd668ae9cca65d92b6f9db0848d9" title="called before this region is cleared">CacheWriter::beforeRegionClear</a> </dd></dl>

</div>
</div>
<a id="a6eacb47a69159ce022c8f9fbc300f61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eacb47a69159ce022c8f9fbc300f61e">&#9670;&nbsp;</a></span>containsKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::containsKey </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyPtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only the client's cache is searched for the key. </p>
<p>It does not go to the java server to which it is connected with. </p>

</div>
</div>
<a id="a5f28c47f8590e9e776ceaed38783008d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f28c47f8590e9e776ceaed38783008d">&#9670;&nbsp;</a></span>containsKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::containsKey </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char* This operations checks for the key in the local cache . </p>
<p>It is not propagated to the Geode cache server to which it is connected. </p>

</div>
</div>
<a id="a0faf7d74dce69c1f0c2adf5e7570290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0faf7d74dce69c1f0c2adf5e7570290e">&#9670;&nbsp;</a></span>containsKeyOnServer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::containsKeyOnServer </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyPtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cache of the server, to which it is connected with, is searched for the key to see if the key is present. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>if the region's scope is ScopeType::LOCAL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af09436efe7a35f65584b562646e90ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09436efe7a35f65584b562646e90ea6">&#9670;&nbsp;</a></span>containsValueForKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::containsValueForKey </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyPtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operations checks for the value in the local cache . </p>
<p>It is not propagated to the Geode cache server to which it is connected. </p>

</div>
</div>
<a id="a60b2ea26884bf10cc79f57c461974b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b2ea26884bf10cc79f57c461974b63">&#9670;&nbsp;</a></span>containsValueForKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::containsValueForKey </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char* This operations checks for the value in the local cache . </p>
<p>It is not propagated to the Geode cache server to which it is connected. </p>

</div>
</div>
<a id="a8929dcdb782d03cfc85fdeb8c2124d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8929dcdb782d03cfc85fdeb8c2124d40">&#9670;&nbsp;</a></span>create() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::create </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new entry in this region with the specified key and value, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. The new entry is propogated to the java server also to which it is connected with. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<p>If remote server put fails throwing back a <code><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></code> or security exception, then local put is tried to rollback. However, if the entry has overflowed/evicted/expired then the rollback is aborted since it may be due to a more recent notification or update by another thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key smart pointer for which to create the entry in this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value for the new entry, which may be nullptr meaning the new entry starts as if it had been locally invalidated. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. Should be serializable if passed to remote callback events </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr or if the key, value, or aCallbackArgument do not meet serializability requirements </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if region is no longer valid </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if the operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00578.html" title="Thrown when the system cannot allocate any more memory.">OutOfMemoryException</a></td><td>if no memory for new entry </td></tr>
    <tr><td class="paramname"><a class="el" href="a00566.html" title="Thrown when attempt is made to create an existing entry.">EntryExistsException</a></td><td>if an entry with this key already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f73f601b6b71f170eb0bdf14893af70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f73f601b6b71f170eb0bdf14893af70">&#9670;&nbsp;</a></span>create() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::create </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a id="ad3ea14cc5de4f7b866a9d67ecd6fb958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ea14cc5de4f7b866a9d67ecd6fb958">&#9670;&nbsp;</a></span>create() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::create </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a6dc2f87e72489bd00bb3b84003aa6395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc2f87e72489bd00bb3b84003aa6395">&#9670;&nbsp;</a></span>create() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::create </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a id="a4f31ce8a0fa5482138b61e943499e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f31ce8a0fa5482138b61e943499e197">&#9670;&nbsp;</a></span>createSubregion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00806.html">Region</a>&gt; apache::geode::client::Region::createSubregion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subregionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00810.html">RegionAttributes</a>&#160;</td>
          <td class="paramname"><em>aRegionAttributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a subregion with the specified attributes. </p>

</div>
</div>
<a id="a1330d8868efec3be5caa7bd04ce8f622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1330d8868efec3be5caa7bd04ce8f622">&#9670;&nbsp;</a></span>destroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::destroy </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the entry with the specified key, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Destroy removes not only the value, but also the key and entry from this region.</p>
<p>The destroy is propogated to the Geode cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></code> or security exception, then the local entry is still destroyed.</p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to destroy </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. If it is sent on the wire, it has to be <a class="el" href="a00846.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Geode cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if the operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if the region is destroyed. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a></td><td>if the entry does not exist in this region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#aaf5d2224d28bb3ec4647138c93d17bf3" title="Invalidates the entry with the specified key, and provides a user-defined argument to the CacheListen...">invalidate</a> </dd>
<dd>
<a class="el" href="a00374.html#ae25df9bc72e208023068fd4f193d4224" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="a00390.html#a81ec54ad91d600062a7020d6639dede8" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a id="a2b785d71a099118536f4ab685325d302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b785d71a099118536f4ab685325d302">&#9670;&nbsp;</a></span>destroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::destroy </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a0e00376744c98bc9d2db341a865c69a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e00376744c98bc9d2db341a865c69a3">&#9670;&nbsp;</a></span>destroyRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::destroyRegion </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>Destroy cascades to all entries and subregions. After the destroy, this region object cannot be used any more. Any attempt to use this region object will get a <code><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></code> exception.</p>
<p>The region destroy not only destroys the local region but also destroys the server region. However, if server region destroy fails throwing back <code><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></code> or security exception, the local region is still destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this call. Can be nullptr. If it is sent on the wire, it has to be <a class="el" href="a00846.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation; if this occurs some subregions may have already been successfully destroyed. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if not connected to the geode system because the client cannot establish usable connections to any of the servers given to it. For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a7b8c7859dda52ac8d4c8400181a9b255" title="Invalidates this region.">invalidateRegion</a> </dd></dl>

</div>
</div>
<a id="a3a367e94055c973a046148b0c9c98bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a367e94055c973a046148b0c9c98bff">&#9670;&nbsp;</a></span>existsValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::existsValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_QUERY_RESPONSE_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the query on the server based on the predicate and returns whether any result exists. </p>
<p>Valid only for a Native Client region. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for the response, optional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If timeout exceeds 2147483647ms. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00626.html" title="Thrown when query exception occurs at the server.">QueryException</a></td><td>if some query error occurred at the server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when the reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00494.html" title="Thrown when an operation is attempted on a closed cache.">CacheClosedException</a></td><td>if the cache has been closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the result size is non-zero, false otherwise. </dd></dl>

</div>
</div>
<a id="a4423292be4f114db87bc14bcf026a9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4423292be4f114db87bc14bcf026a9f7">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00846.html">Cacheable</a>&gt; apache::geode::client::Region::get </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value associated with the specified key, passing the callback argument to any cache loaders that are invoked in the operation. </p>
<p>If the value is not present locally then it is requested from the java server. If even that is unsuccessful then a local <a class="el" href="a00378.html" title="An application plug-in that can be installed on a region.">CacheLoader</a> will be invoked if there is one. The value returned by get is not copied, so multi-threaded applications should not modify the value directly, but should use the update methods. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a>, <a class="el" href="">CacheStatistics::getHitCount</a>, {<a class="el" href="">}, and { CacheStatistics::getLastModifiedTime} (if a new value is loaded) for this region and the entry.  key whose associated value is to be returned. The key Object must implement the equals and hashCode methods.  aCallbackArgument an argument passed into the CacheLoader if loader is used. If it is sent on the wire, it has to be Serializable.   IllegalArgumentException if key is nullptr or aCallbackArgument is not serializable and a remote CacheLoader needs to be invoked  CacheLoaderException if CacheLoader throws an exception  CacheServerException If an exception is received from the Java cache server. Only for Native Client regions.  NotConnectedException if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException.  MessageExcepton If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log.  TimeoutException if operation timed out  RegionDestroyedException if the method is called on a destroyed region </a></p>

</div>
</div>
<a id="a5f75d99d826c24cfe3b516f965790a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75d99d826c24cfe3b516f965790a1a">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a00846.html">Cacheable</a>&gt; apache::geode::client::Region::get </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callbackArg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="ae9cd6bbcccae9c07a813f4f38b1977a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cd6bbcccae9c07a813f4f38b1977a7">&#9670;&nbsp;</a></span>getAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HashMapOfCacheable apache::geode::client::Region::getAll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets values for an array of keys from the local cache or server. </p>
<p>If value for a key is not present locally then it is requested from the java server. The value returned is not copied, so multi-threaded applications should not modify the value directly, but should use the update methods. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a>, <a class="el" href="">CacheStatistics::getHitCount</a> and {<a class="el" href="">} for this region and the entry.  keys the array of keys  values Output parameter that provides the map of keys to respective values. It is ignored if nullptr, and when nullptr then at least the <code>addToLocalCache</code> parameter should be true and caching should be enabled for the region to get values into the region otherwise an <code>IllegalArgumentException</code> is thrown.  exceptions Output parameter that provides the map of keys to any exceptions while obtaining the key. It is ignored if nullptr.  8.1  aCallbackArgument an argument that is passed to the callback functions. It may be nullptr. Must be serializable if this operation is distributed.  IllegalArgumentException If the array of keys is empty. Other invalid case is when the <code>values</code> parameter is nullptr, and either <code>addToLocalCache</code> is false or caching is disabled for this region.  CacheServerException If an exception is received from the Java cache server while processing the request.  NotConnectedException if it is not connected to the cache because the client cannot establish usable connections to any of the given servers For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException.  RegionDestroyedException If region destroy is pending.  TimeoutException if operation timed out.  UnknownException For other exceptions.   get </a></p>

</div>
</div>
<a id="ac2cc9292b643aa332f13c79c24c5dbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cc9292b643aa332f13c79c24c5dbb6">&#9670;&nbsp;</a></span>getAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="a00810.html">RegionAttributes</a>&amp; apache::geode::client::Region::getAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="a00810.html" title="Defines attributes for configuring a region.">RegionAttributes</a> for this region. </p>

</div>
</div>
<a id="a2adce4f4840cd90bcddeee212f818b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adce4f4840cd90bcddeee212f818b65">&#9670;&nbsp;</a></span>getAttributesMutator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00274.html">AttributesMutator</a>&gt; apache::geode::client::Region::getAttributesMutator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the a mutator object for changing a subset of the region attributes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RegionDestroyedException.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1df8721137a736b7beb58829d3be167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df8721137a736b7beb58829d3be167f">&#9670;&nbsp;</a></span>getEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00818.html">RegionEntry</a>&gt; apache::geode::client::Region::getEntry </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the meta-object <a class="el" href="a00818.html" title="An object in a Region that represents an entry, i.e., a key-value pair.">RegionEntry</a> for key. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a>,RegionDestroyedException.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8540a02a3d036f8212c1c9556bd9959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8540a02a3d036f8212c1c9556bd9959e">&#9670;&nbsp;</a></span>getEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a00818.html">RegionEntry</a>&gt; apache::geode::client::Region::getEntry </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a121f22e1598bee66ea6106d6359c61de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121f22e1598bee66ea6106d6359c61de">&#9670;&nbsp;</a></span>getFullPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; apache::geode::client::Region::getFullPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the full path of the region as can be used to lookup the region from <a class="el" href="a00286.html#af80a5d73de38233b22e409fe55c51a00" title="Look up a region with the full path from root.">Cache::getRegion</a>. </p>
<p>The storage is backed by the region. </p>

</div>
</div>
<a id="ace982eee9216ad3fdec5da966fb1f1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace982eee9216ad3fdec5da966fb1f1ba">&#9670;&nbsp;</a></span>getInterestList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::shared_ptr&lt;<a class="el" href="a00338.html">CacheableKey</a>&gt; &gt; apache::geode::client::Region::getInterestList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of keys on which this client is interested and will be notified of changes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>if the region's scope is ScopeType::LOCAL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ca0d0be77447b032d8e605c742db03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ca0d0be77447b032d8e605c742db03">&#9670;&nbsp;</a></span>getInterestListRegex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::shared_ptr&lt;<a class="el" href="a00358.html">CacheableString</a>&gt; &gt; apache::geode::client::Region::getInterestListRegex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of regular expresssions on which this client is interested and will be notified of changes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>if the region's scope is ScopeType::LOCAL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add7b892f9946cd913d961e50367edc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7b892f9946cd913d961e50367edc7f">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; apache::geode::client::Region::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Public Methods. </p>
<p>return single name of region. The storage is backed by the region. </p>

</div>
</div>
<a id="a9a581207a44891db2a6df2e65e4e9a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a581207a44891db2a6df2e65e4e9a2c">&#9670;&nbsp;</a></span>getParentRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00806.html">Region</a>&gt; apache::geode::client::Region::getParentRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent region, or nullptr if a root region. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac235fcbacdc1d6db5fb616aafd3f57aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac235fcbacdc1d6db5fb616aafd3f57aa">&#9670;&nbsp;</a></span>getRegionService()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00830.html">RegionService</a>&amp; apache::geode::client::Region::getRegionService </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>cache</code> associated with this region. </p>
<dl class="section return"><dt>Returns</dt><dd>the cache </dd></dl>

</div>
</div>
<a id="a34809291097fec7446b80a004a7ed692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34809291097fec7446b80a004a7ed692">&#9670;&nbsp;</a></span>getSubregion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00806.html">Region</a>&gt; apache::geode::client::Region::getSubregion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the subregion identified by the path, nullptr if no such subregion. </p>

</div>
</div>
<a id="aaf5d2224d28bb3ec4647138c93d17bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5d2224d28bb3ec4647138c93d17bf3">&#9670;&nbsp;</a></span>invalidate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::invalidate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates the entry with the specified key, and provides a user-defined argument to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>. </p>
<p>Invalidate only removes the value from the entry, the key is kept intact. To completely remove the entry, destroy should be used. The invalidate is not propogated to the Geode cache server to which it is connected with. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the value to be invalidated </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. Should be serializable if passed to remote callback events </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a></td><td>if this entry does not exist in this region locally </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if the region is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="a00374.html#a42a3838742960796df2fb6668bf8d108" title="Handles the event of an entry&#39;s value being invalidated.">CacheListener::afterInvalidate</a> </dd></dl>

</div>
</div>
<a id="a8b1016552d35db8e66fbc5ff9677fd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1016552d35db8e66fbc5ff9677fd81">&#9670;&nbsp;</a></span>invalidate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::invalidate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a7b8c7859dda52ac8d4c8400181a9b255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8c7859dda52ac8d4c8400181a9b255">&#9670;&nbsp;</a></span>invalidateRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::invalidateRegion </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates this region. </p>
<p>The invalidation will cascade to all the subregions and cached entries. After the <code>invalidateRegion</code> , the region and the entries in it still exist. In order to remove all the entries and the region, <code>destroyRegion</code> should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. If it is sent on the wire, it has to be <a class="el" href="a00846.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if the region is no longer valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a0e00376744c98bc9d2db341a865c69a3" title="Destroys the whole region and provides a user-defined parameter object to any CacheWriter invoked in ...">destroyRegion</a> </dd>
<dd>
<a class="el" href="a00374.html#ad6e1fd0a48407e6bfb4242784fc2ca4a" title="Handles the event of a region being invalidated.">CacheListener::afterRegionInvalidate</a> This operation is not distributed. </dd></dl>

</div>
</div>
<a id="a9bd81fa0496c7857e8002857adc5222b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd81fa0496c7857e8002857adc5222b">&#9670;&nbsp;</a></span>keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::shared_ptr&lt;<a class="el" href="a00338.html">CacheableKey</a>&gt; &gt; apache::geode::client::Region::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all the keys in the local process for this region. </p>
<p>This includes keys for which the entry is invalid. </p>

</div>
</div>
<a id="a3ad98b833f6a7fa2f523e4f9c48e156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad98b833f6a7fa2f523e4f9c48e156c">&#9670;&nbsp;</a></span>localClear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::localClear </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process. </p>
<p>Clear will not be distributed to other caches. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00374.html#ae81f5fe95bd0a2ad570a273a4e3ccd2f" title="Handles the event of a region being cleared.">CacheListener::afterRegionClear</a> </dd>
<dd>
<a class="el" href="a00390.html#a1fc3cd668ae9cca65d92b6f9db0848d9" title="called before this region is cleared">CacheWriter::beforeRegionClear</a> </dd></dl>

</div>
</div>
<a id="ab7d53cf0407f8ffbcd469cb8184d992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d53cf0407f8ffbcd469cb8184d992a">&#9670;&nbsp;</a></span>localCreate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new entry in this region with the specified key and value in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key smart pointer for which to create the entry in this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value for the new entry, which may be nullptr meaning the new entry starts as if it had been locally invalidated. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. Should be serializable if passed to remote callback events</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key or value is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if region is no longer valid </td></tr>
    <tr><td class="paramname"><a class="el" href="a00578.html" title="Thrown when the system cannot allocate any more memory.">OutOfMemoryException</a></td><td>if no memory for new entry </td></tr>
    <tr><td class="paramname"><a class="el" href="a00566.html" title="Thrown when attempt is made to create an existing entry.">EntryExistsException</a></td><td>if an entry with this key already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12d5df0f3da39624e8b91374c4d0cc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d5df0f3da39624e8b91374c4d0cc4d">&#9670;&nbsp;</a></span>localCreate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a id="a803c712c4b8fb815312ba65c35f8f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803c712c4b8fb815312ba65c35f8f638">&#9670;&nbsp;</a></span>localCreate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a618ea2e7439a0fc8a49085fc6246cfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618ea2e7439a0fc8a49085fc6246cfed">&#9670;&nbsp;</a></span>localCreate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a id="ae15edb6a306b2034de0c0fed001fe77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15edb6a306b2034de0c0fed001fe77f">&#9670;&nbsp;</a></span>localDestroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::localDestroy </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Destroy removes not only the value but also the key and entry from this region. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to destroy. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>the callback for user to pass in, default is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a></td><td>if the entry does not exist in this region locally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#aaf5d2224d28bb3ec4647138c93d17bf3" title="Invalidates the entry with the specified key, and provides a user-defined argument to the CacheListen...">invalidate</a> </dd>
<dd>
<a class="el" href="a00374.html#ae25df9bc72e208023068fd4f193d4224" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="a00390.html#a81ec54ad91d600062a7020d6639dede8" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a id="a4da6a035aa53cd86a0a111160bdfcbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da6a035aa53cd86a0a111160bdfcbbc">&#9670;&nbsp;</a></span>localDestroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localDestroy </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a7572b61d45c19a28667779c68e44869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7572b61d45c19a28667779c68e44869b">&#9670;&nbsp;</a></span>localDestroyRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::localDestroyRegion </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>Destroy cascades to all entries and subregions. After the destroy, this region object cannot be used any more. Any attempt to use this region object will get a <code><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></code> exception. The region destroy is not distributed to other caches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this call. Can be nullptr. If it is sent on the wire, it has to be <a class="el" href="a00846.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation; if this occurs some subregions may have already been successfully destroyed. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a8a2aa318cee5209815bec5dcad3db3c3" title="Invalidates this region.">localInvalidateRegion</a> </dd></dl>

</div>
</div>
<a id="aec2bad01768d7c54470dc6364fd1d9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2bad01768d7c54470dc6364fd1d9c1">&#9670;&nbsp;</a></span>localInvalidate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::localInvalidate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates the entry with the specified key in the local cache only, and provides a user-defined argument to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>. </p>
<p>Invalidate only removes the value from the entry, the key is kept intact. To completely remove the entry, destroy should be used. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the value to be invalidated </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. Should be serializable if passed to remote callback events </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a></td><td>if this entry does not exist in this region locally </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if the region is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="a00374.html#a42a3838742960796df2fb6668bf8d108" title="Handles the event of an entry&#39;s value being invalidated.">CacheListener::afterInvalidate</a> </dd></dl>

</div>
</div>
<a id="a26dcb92f1d653430aaf87c577eaef4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dcb92f1d653430aaf87c577eaef4ea">&#9670;&nbsp;</a></span>localInvalidate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localInvalidate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a8a2aa318cee5209815bec5dcad3db3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2aa318cee5209815bec5dcad3db3c3">&#9670;&nbsp;</a></span>localInvalidateRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::localInvalidateRegion </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates this region. </p>
<p>The invalidation will cascade to all the subregions and cached entries. After the <code>invalidateRegion</code> , the region and the entries in it still exist. In order to remove all the entries and the region, <code>destroyRegion</code> should be used. The region invalidate will not be distributed to other caches</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. If it is sent on the wire, it has to be <a class="el" href="a00846.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if the region is no longer valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a0e00376744c98bc9d2db341a865c69a3" title="Destroys the whole region and provides a user-defined parameter object to any CacheWriter invoked in ...">destroyRegion</a> </dd>
<dd>
<a class="el" href="a00374.html#ad6e1fd0a48407e6bfb4242784fc2ca4a" title="Handles the event of a region being invalidated.">CacheListener::afterRegionInvalidate</a> </dd></dl>

</div>
</div>
<a id="a56b987344899b83ff9e3a786adc2f8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b987344899b83ff9e3a786adc2f8ec">&#9670;&nbsp;</a></span>localPut() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a new value into an entry in this region with the specified key in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. If there is already an entry associated with the specified key in this region, the entry's previous value is overwritten. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key smart pointer associated with the value to be put into this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value to be put into the cache </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key or value is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if region no longer valid </td></tr>
    <tr><td class="paramname"><a class="el" href="a00578.html" title="Thrown when the system cannot allocate any more memory.">OutOfMemoryException</a></td><td>if not enoough memory for the value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a795a7a96f8d6bf78efe9cfe88dc359e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795a7a96f8d6bf78efe9cfe88dc359e0">&#9670;&nbsp;</a></span>localPut() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a id="a7e88f748827b7492d9e63262b7213fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e88f748827b7492d9e63262b7213fec">&#9670;&nbsp;</a></span>localPut() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a67c0922b4263f6a56f77bf0c400a530d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c0922b4263f6a56f77bf0c400a530d">&#9670;&nbsp;</a></span>localPut() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a id="a5d81acc0a327cae9fc19501d8cc83e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d81acc0a327cae9fc19501d8cc83e44">&#9670;&nbsp;</a></span>localRemove() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key and value in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Remove removes not only the value but also the key and entry from this region. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the entry to remove. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>the callback for user to pass in, default is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="a00374.html#ae25df9bc72e208023068fd4f193d4224" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="a00390.html#a81ec54ad91d600062a7020d6639dede8" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a id="a5db734c1ebff0e40b383583aa8b40d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db734c1ebff0e40b383583aa8b40d0d">&#9670;&nbsp;</a></span>localRemove() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a id="ab4f4f753f6d82d5ff1d16335ca0f6ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f4f753f6d82d5ff1d16335ca0f6ad6">&#9670;&nbsp;</a></span>localRemove() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="af70a334dc5a2eed774d3cfb18dca7588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70a334dc5a2eed774d3cfb18dca7588">&#9670;&nbsp;</a></span>localRemove() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a id="a817c35ed57ec56328b77cf56fd854bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817c35ed57ec56328b77cf56fd854bd3">&#9670;&nbsp;</a></span>localRemoveEx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::localRemoveEx </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Remove removes not only the value but also the key and entry from this region. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>the callback for user to pass in, default is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="a00374.html#ae25df9bc72e208023068fd4f193d4224" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="a00390.html#a81ec54ad91d600062a7020d6639dede8" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a id="a5ab0f1aaee2012f4078ddef9cbcd0f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab0f1aaee2012f4078ddef9cbcd0f77">&#9670;&nbsp;</a></span>localRemoveEx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::localRemoveEx </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a6d37f770f04349d9c06799ab2ea4329e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d37f770f04349d9c06799ab2ea4329e">&#9670;&nbsp;</a></span>put() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::put </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a new value into an entry in this region with the specified key, providing a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. If there is already an entry associated with the specified key in this region, the entry's previous value is overwritten. The new put value is propogated to the java server to which it is connected with. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry.</p>
<p>If remote server put fails throwing back a <code><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></code> or security exception, then local put is tried to rollback. However, if the entry has overflowed/evicted/expired then the rollback is aborted since it may be due to a more recent notification or update by another thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key smart pointer associated with the value to be put into this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value to be put into the cache </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key or value is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if region no longer valid </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00578.html" title="Thrown when the system cannot allocate any more memory.">OutOfMemoryException</a></td><td>if not enoough memory for the value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ced28273734ba50a42b301461fd3192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ced28273734ba50a42b301461fd3192">&#9670;&nbsp;</a></span>put() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::put </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a id="aecb0037ec09ed1f38ff6d4094110442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb0037ec09ed1f38ff6d4094110442a">&#9670;&nbsp;</a></span>put() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::put </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a69113f479f312a834583d7bde304d532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69113f479f312a834583d7bde304d532">&#9670;&nbsp;</a></span>put() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::Region::put </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a id="ad01ef3839d72091410d7261a91a34729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01ef3839d72091410d7261a91a34729">&#9670;&nbsp;</a></span>putAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::putAll </td>
          <td>(</td>
          <td class="paramtype">const HashMapOfCacheable &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_RESPONSE_TIMEOUT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a set of new values in this region with the specified keys given as a map of key/value pairs. </p>
<p>If there is already an entry associated with a specified key in this region, the entry's previous value is overwritten. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A hashmap containing key-value pairs </td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for the response, optional. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback functions. It is ignored if nullptr. It must be serializable if this operation is distributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If timeout exceeds 2147483647ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>8.1 </dd></dl>

</div>
</div>
<a id="a77aa2905866218924960c3d4d8336e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aa2905866218924960c3d4d8336e1f">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00842.html">SelectResults</a>&gt; apache::geode::client::Region::query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_QUERY_RESPONSE_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the query on the server based on the predicate. </p>
<p>Valid only for a Native Client region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for the query response, optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If timeout exceeds 2147483647ms. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00626.html" title="Thrown when query exception occurs at the server.">QueryException</a></td><td>if some query error occurred at the server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00494.html" title="Thrown when an operation is attempted on a closed cache.">CacheClosedException</a></td><td>if the cache has been closed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the <a class="el" href="a00842.html" title="A SelectResults is obtained by executing a Query on the server.">SelectResults</a> which can either be a <a class="el" href="a00838.html" title="A ResultSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">ResultSet</a> or a <a class="el" href="a00854.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">StructSet</a>. </dd></dl>

</div>
</div>
<a id="a831b5bac108bd92dd436ffad49d859c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831b5bac108bd92dd436ffad49d859c2">&#9670;&nbsp;</a></span>registerAllKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::registerAllKeys </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>receiveValues</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers to get updates for all keys from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">RegionAttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isDurable</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td class="paramname">getInitialValues</td><td>true to populate the cache with values of all keys from the server </td></tr>
    <tr><td class="paramname">receiveValues</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a></td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>If the region is not a Native Client region or <a class="el" href="">RegionAttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00542.html" title="An unknown exception occurred.">UnknownException</a></td><td>For other exceptions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f9a5fcce916d2e353d0da6c72fb8695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9a5fcce916d2e353d0da6c72fb8695">&#9670;&nbsp;</a></span>registerKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::registerKeys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>receiveValues</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an array of keys for getting updates from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">RegionAttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>the array of keys </td></tr>
    <tr><td class="paramname">isDurable</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td class="paramname">getInitialValues</td><td>true to populate the cache with values of the keys that were registered on the server </td></tr>
    <tr><td class="paramname">receiveValues</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If the array of keys is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00470.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>If already registered interest for all keys. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a></td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>If the region is not a Native Client region or <a class="el" href="">RegionAttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00542.html" title="An unknown exception occurred.">UnknownException</a></td><td>For other exceptions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2018c44f6006a5d6edf68cdec8ffec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2018c44f6006a5d6edf68cdec8ffec0">&#9670;&nbsp;</a></span>registerRegex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::registerRegex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>receiveValues</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a regular expression to match with keys to get updates from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">RegionAttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>The regular expression string. </td></tr>
    <tr><td class="paramname">isDurable</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td class="paramname">resultKeys</td><td>If non-nullptr then the keys that match the regular expression on the server are returned. The vector is cleared at the start to discard any existing keys in the vector. </td></tr>
    <tr><td class="paramname">getInitialValues</td><td>true to populate the cache with values of the keys that were registered on the server </td></tr>
    <tr><td class="paramname">receiveValues</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If regex is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00470.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>If already registered interest for all keys. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a></td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>If the region is not a Native Client region or <a class="el" href="">RegionAttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00542.html" title="An unknown exception occurred.">UnknownException</a></td><td>For other exceptions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93d7580c858e42f4288ad9035a77e3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d7580c858e42f4288ad9035a77e3e6">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key, value and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. remove removes not only the value, but also the key and entry from this region.</p>
<p>The remove is propogated to the Geode cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></code> or security exception, then the local entry is still removed.</p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove </td></tr>
    <tr><td class="paramname">value</td><td>the value of the key to remove, it can be nullptr. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. If it is sent on the wire, it has to be <a class="el" href="a00846.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Geode cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if the operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if the region is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="a00374.html#ae25df9bc72e208023068fd4f193d4224" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="a00390.html#a81ec54ad91d600062a7020d6639dede8" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a id="ac57a717df98aab2ee922d9cb6d1f9ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57a717df98aab2ee922d9cb6d1f9ab3">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a id="ade0389e6ce08e4256e990357b3977dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0389e6ce08e4256e990357b3977dfa">&#9670;&nbsp;</a></span>remove() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Cacheable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="a5c2743de0f0decb4b36bfddfa22aaf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2743de0f0decb4b36bfddfa22aaf84">&#9670;&nbsp;</a></span>remove() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a id="a82e296f91e1f08868cb7b1c76180d37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e296f91e1f08868cb7b1c76180d37c">&#9670;&nbsp;</a></span>remove() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a id="a9d35d2cfdcbe1bfcd050d5beb154db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d35d2cfdcbe1bfcd050d5beb154db8f">&#9670;&nbsp;</a></span>removeAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::removeAll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all of the entries for the specified keys from this region. </p>
<p>The effect of this call is equivalent to that of calling <a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622">destroy</a> on this region once for each key in the specified collection. If an entry does not exist that key is skipped; <a class="el" href="a00550.html" title="Thrown when an operation is attempted on a non-existent entry.">EntryNotFoundException</a> is not thrown. </p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entries. </p><dl class="section since"><dt>Since</dt><dd>8.1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>the keys to remove from this region. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback functions. It is ignored if nullptr. It must be serializable if this operation is distributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If the array of keys is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server while processing the request. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the given servers For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00542.html" title="An unknown exception occurred.">UnknownException</a></td><td>For other exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd></dl>

</div>
</div>
<a id="a9273d5b4ff2266ddeb298e3b3d186cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9273d5b4ff2266ddeb298e3b3d186cec">&#9670;&nbsp;</a></span>removeEx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::Region::removeEx </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key and provides a user-defined parameter object to any <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="a00806.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. remove removes not only the value, but also the key and entry from this region.</p>
<p>The remove is propogated to the Geode cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></code> or security exception, then the local entry is still removed.</p>
<p>Updates the <a class="el" href="a00382.html#a9b0fc218ad21944661f8174a3ff9167f">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="a00382.html#af895fb77a5b22a015860ca9220f90124">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be nullptr. If it is sent on the wire, it has to be <a class="el" href="a00846.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>if key is nullptr </td></tr>
    <tr><td class="paramname"><a class="el" href="a00486.html" title="Thrown when the cache writer aborts the operation.">CacheWriterException</a></td><td>if <a class="el" href="a00390.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname"><a class="el" href="a00650.html" title="Thrown when the cache listener throws an exception.">CacheListenerException</a></td><td>if <a class="el" href="a00374.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Geode cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if the operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>if the region is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00806.html#a1330d8868efec3be5caa7bd04ce8f622" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="a00374.html#ae25df9bc72e208023068fd4f193d4224" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="a00390.html#a81ec54ad91d600062a7020d6639dede8" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a id="a7182d61675e7c19c980f955c301d89b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7182d61675e7c19c980f955c301d89b5">&#9670;&nbsp;</a></span>removeEx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apache::geode::client::Region::removeEx </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="a00846.html">Serializable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a id="aec3eb9ab90811f9cc4d46d7663626381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3eb9ab90811f9cc4d46d7663626381">&#9670;&nbsp;</a></span>selectValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00846.html">Serializable</a>&gt; apache::geode::client::Region::selectValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_QUERY_RESPONSE_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the query on the server based on the predicate and returns a single result value. </p>
<p>Valid only for a Native Client region. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time to wait for the response, optional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If timeout exceeds 2147483647ms. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00626.html" title="Thrown when query exception occurs at the server.">QueryException</a></td><td>if some query error occurred at the server, or more than one result items are available. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
    <tr><td class="paramname"><a class="el" href="a00494.html" title="Thrown when an operation is attempted on a closed cache.">CacheClosedException</a></td><td>if the cache has been closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the single <a class="el" href="a00838.html" title="A ResultSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">ResultSet</a> or <a class="el" href="a00854.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">StructSet</a> item, or nullptr of no results are available. </dd></dl>

</div>
</div>
<a id="a4d1f765d6525702103c2d9d090ff7982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1f765d6525702103c2d9d090ff7982">&#9670;&nbsp;</a></span>serverKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::shared_ptr&lt;<a class="el" href="a00338.html">CacheableKey</a>&gt; &gt; apache::geode::client::Region::serverKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of keys defined in the server process associated to this client and region. </p>
<p>If a server has the region defined as a mirror, then this will be the entire keyset for the region across all PEER in the distributed system. The vector v will contain only the server keys. Any prior contents in the vector will be removed. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Geode cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if there is a timeout getting the keys </td></tr>
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>if the member type is not CLIENT or region is not a native client one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa01b37fec3c6097344a89b34e1799018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01b37fec3c6097344a89b34e1799018">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t apache::geode::client::Region::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of region. </p>
<p>For native client regions, this will give the number of entries in the local cache and not on the servers. </p>

</div>
</div>
<a id="ab66ef3e6ca701076e8328ff17c3f1d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66ef3e6ca701076e8328ff17c3f1d09">&#9670;&nbsp;</a></span>subregions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::shared_ptr&lt;<a class="el" href="a00806.html">Region</a>&gt; &gt; apache::geode::client::Region::subregions </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recursive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populates the passed in std::vector&lt;std::shared_ptr&lt;Region&gt;&gt; with subregions of the current region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">recursive</td><td>determines whether the method recursively fills in subregions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sr</td><td>subregions </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c32984b1fda64e87f35a4ce29762c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c32984b1fda64e87f35a4ce29762c72">&#9670;&nbsp;</a></span>unregisterAllKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::unregisterAllKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers to get updates for all keys from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">RegionAttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00470.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>If not previously registered all keys. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>If the region is not a Native Client region or <a class="el" href="">RegionAttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00542.html" title="An unknown exception occurred.">UnknownException</a></td><td>For other exceptions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f17fec44de821243e963e49bb7bb410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f17fec44de821243e963e49bb7bb410">&#9670;&nbsp;</a></span>unregisterKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::unregisterKeys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="a00338.html">CacheableKey</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters an array of keys to stop getting updates for them. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">RegionAttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>the array of keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If the array of keys is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00470.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>If no keys were previously registered. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>If the region is not a Native Client region or <a class="el" href="">RegionAttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00542.html" title="An unknown exception occurred.">UnknownException</a></td><td>For other exceptions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea9da5d2aa1728197efc0a0caf43c539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9da5d2aa1728197efc0a0caf43c539">&#9670;&nbsp;</a></span>unregisterRegex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::Region::unregisterRegex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters a regular expression to stop getting updates for keys from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">RegionAttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>The regular expression string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00466.html" title="Thrown when an argument to a method is illegal.">IllegalArgumentException</a></td><td>If regex is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00470.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>If not previously registered this regular expression string. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00530.html" title="Thrown when an operation unsupported by the current configuration is attempted.">UnsupportedOperationException</a></td><td>If the region is not a Native Client region or <a class="el" href="">RegionAttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00618.html" title="Thrown when an exception occurs on the cache server.">CacheServerException</a></td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a></td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of <a class="el" href="a00570.html" title="Thrown when an operation is attempted before connecting to the distributed system.">NotConnectedException</a> is set to <a class="el" href="a00678.html" title="Thrown if the No locators are active to reply for new connection.">NoAvailableLocatorsException</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00506.html" title="Thrown when an operation is attempted on a destroyed region.">RegionDestroyedException</a></td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00542.html" title="An unknown exception occurred.">UnknownException</a></td><td>For other exceptions. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00482.html" title="Thrown when a timout occurs.">TimeoutException</a></td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff8edb4375cc9a76336871f1f7c5cd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8edb4375cc9a76336871f1f7c5cd39">&#9670;&nbsp;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::shared_ptr&lt;<a class="el" href="a00846.html">Cacheable</a>&gt; &gt; apache::geode::client::Region::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all values in the local process for this region. </p>
<p>No value is included for entries that are invalidated. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<HR><address style="align: right;"><small>Apache Geode C++ Cache API Documentation</small></address>
