<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Geode Native C++ Reference: apache::geode::client::PdxInstance Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Geode Native C++ Reference
   &#160;<span id="projectnumber">1.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00749.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">apache::geode::client::PdxInstance Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> provides run time access to the fields of a PDX without deserializing the PDX.  
 <a href="a00749.html#details">More...</a></p>

<p>Inherits <a class="el" href="a00761.html">apache::geode::client::PdxSerializable</a>.</p>

<p>Inherited by <a class="el" href="a00881.html">apache::geode::client::WritablePdxInstance</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8e8a42bfedd76fec24cfff33fbdd93a"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00881.html">WritablePdxInstance</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#af8e8a42bfedd76fec24cfff33fbdd93a">createWriter</a> ()=0</td></tr>
<tr class="memdesc:af8e8a42bfedd76fec24cfff33fbdd93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="a00881.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#af8e8a42bfedd76fec24cfff33fbdd93a">More...</a><br /></td></tr>
<tr class="separator:af8e8a42bfedd76fec24cfff33fbdd93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e789d8e4da85f4ec586bd16b737001"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#aa3e789d8e4da85f4ec586bd16b737001">fromData</a> (<a class="el" href="a00757.html">PdxReader</a> &amp;input) override=0</td></tr>
<tr class="memdesc:aa3e789d8e4da85f4ec586bd16b737001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize this object.  <a href="#aa3e789d8e4da85f4ec586bd16b737001">More...</a><br /></td></tr>
<tr class="separator:aa3e789d8e4da85f4ec586bd16b737001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a96b719b63a9cbc7eb63f2781cae7d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#ad6a96b719b63a9cbc7eb63f2781cae7d">getBooleanArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:ad6a96b719b63a9cbc7eb63f2781cae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in bool array type out param.  <a href="#ad6a96b719b63a9cbc7eb63f2781cae7d">More...</a><br /></td></tr>
<tr class="separator:ad6a96b719b63a9cbc7eb63f2781cae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14050655be9f0e5d0b98ca8cd58ebe7f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a14050655be9f0e5d0b98ca8cd58ebe7f">getBooleanField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a14050655be9f0e5d0b98ca8cd58ebe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in bool type out param.  <a href="#a14050655be9f0e5d0b98ca8cd58ebe7f">More...</a><br /></td></tr>
<tr class="separator:a14050655be9f0e5d0b98ca8cd58ebe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5367cf178da27aecddc44ac48ce595"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a6a5367cf178da27aecddc44ac48ce595">getByteArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a6a5367cf178da27aecddc44ac48ce595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in signed char array type out param.  <a href="#a6a5367cf178da27aecddc44ac48ce595">More...</a><br /></td></tr>
<tr class="separator:a6a5367cf178da27aecddc44ac48ce595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48742741670329aba1d48b25964f2789"><td class="memItemLeft" align="right" valign="top">virtual int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a48742741670329aba1d48b25964f2789">getByteField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a48742741670329aba1d48b25964f2789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in signed char type out param.  <a href="#a48742741670329aba1d48b25964f2789">More...</a><br /></td></tr>
<tr class="separator:a48742741670329aba1d48b25964f2789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813be08753e160b30b0353c9cc5cd0c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00329.html">CacheableDate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#ad813be08753e160b30b0353c9cc5cd0c">getCacheableDateField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:ad813be08753e160b30b0353c9cc5cd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in std::shared_ptr&lt;CacheableDate&gt; type out param.  <a href="#ad813be08753e160b30b0353c9cc5cd0c">More...</a><br /></td></tr>
<tr class="separator:ad813be08753e160b30b0353c9cc5cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbe4efe8ed166011ff68a76e78ba96c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00853.html">Cacheable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#affbe4efe8ed166011ff68a76e78ba96c">getCacheableField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:affbe4efe8ed166011ff68a76e78ba96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in std::shared_ptr&lt;Cacheable&gt; type out param.  <a href="#affbe4efe8ed166011ff68a76e78ba96c">More...</a><br /></td></tr>
<tr class="separator:affbe4efe8ed166011ff68a76e78ba96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b598e4b18862e6e6788a6ba24a05d0"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00357.html">CacheableObjectArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a08b598e4b18862e6e6788a6ba24a05d0">getCacheableObjectArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a08b598e4b18862e6e6788a6ba24a05d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in std::shared_ptr&lt;CacheableObjectArray&gt; type out param.  <a href="#a08b598e4b18862e6e6788a6ba24a05d0">More...</a><br /></td></tr>
<tr class="separator:a08b598e4b18862e6e6788a6ba24a05d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cc4bf08dbaceb3cd8b59b5015b364f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; char16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#ae9cc4bf08dbaceb3cd8b59b5015b364f">getCharArrayField</a> (const std::string &amp;fieldName) const =0</td></tr>
<tr class="memdesc:ae9cc4bf08dbaceb3cd8b59b5015b364f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in char array type out param.  <a href="#ae9cc4bf08dbaceb3cd8b59b5015b364f">More...</a><br /></td></tr>
<tr class="separator:ae9cc4bf08dbaceb3cd8b59b5015b364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88b879c6497ebea32d09be9a85964d3"><td class="memItemLeft" align="right" valign="top">virtual char16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#ad88b879c6497ebea32d09be9a85964d3">getCharField</a> (const std::string &amp;fieldName) const =0</td></tr>
<tr class="memdesc:ad88b879c6497ebea32d09be9a85964d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in char type out param.  <a href="#ad88b879c6497ebea32d09be9a85964d3">More...</a><br /></td></tr>
<tr class="separator:ad88b879c6497ebea32d09be9a85964d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2912c23ab766cb21e711088dd3b0c1fb"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a2912c23ab766cb21e711088dd3b0c1fb">getClassName</a> () const override=0</td></tr>
<tr class="memdesc:a2912c23ab766cb21e711088dd3b0c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full name of the class that this pdx instance represents.  <a href="#a2912c23ab766cb21e711088dd3b0c1fb">More...</a><br /></td></tr>
<tr class="separator:a2912c23ab766cb21e711088dd3b0c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba80875c282330e1d20e7846506ec70"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a9ba80875c282330e1d20e7846506ec70">getDoubleArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a9ba80875c282330e1d20e7846506ec70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in double array type out param.  <a href="#a9ba80875c282330e1d20e7846506ec70">More...</a><br /></td></tr>
<tr class="separator:a9ba80875c282330e1d20e7846506ec70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdaa0cbd2791e46eb56b34f7d945bfa"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#accdaa0cbd2791e46eb56b34f7d945bfa">getDoubleField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:accdaa0cbd2791e46eb56b34f7d945bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in double type out param.  <a href="#accdaa0cbd2791e46eb56b34f7d945bfa">More...</a><br /></td></tr>
<tr class="separator:accdaa0cbd2791e46eb56b34f7d945bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676bf0537b037822cc335e69068c078a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a676bf0537b037822cc335e69068c078a">getField</a> (const std::string &amp;fieldName, int8_t ***value, int32_t &amp;arrayLength, int32_t *&amp;elementLength) const =0</td></tr>
<tr class="memdesc:a676bf0537b037822cc335e69068c078a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in array of byte arrays type out param.  <a href="#a676bf0537b037822cc335e69068c078a">More...</a><br /></td></tr>
<tr class="separator:a676bf0537b037822cc335e69068c078a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3cb5ba5c09771f1cc30238e54a7c3d"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00026.html#abb5c1ce32786fe2c0f7793809b103737">CacheableStringArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#aef3cb5ba5c09771f1cc30238e54a7c3d">getFieldNames</a> ()=0</td></tr>
<tr class="memdesc:aef3cb5ba5c09771f1cc30238e54a7c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unmodifiable list of the field names on this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#aef3cb5ba5c09771f1cc30238e54a7c3d">More...</a><br /></td></tr>
<tr class="separator:aef3cb5ba5c09771f1cc30238e54a7c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3cce44ea9beec3803807e5ab744723"><td class="memItemLeft" align="right" valign="top">virtual PdxFieldTypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#acc3cce44ea9beec3803807e5ab744723">getFieldType</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:acc3cce44ea9beec3803807e5ab744723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type.  <a href="#acc3cce44ea9beec3803807e5ab744723">More...</a><br /></td></tr>
<tr class="separator:acc3cce44ea9beec3803807e5ab744723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9cc727418b2f03e3dde312fe720902"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#acd9cc727418b2f03e3dde312fe720902">getFloatArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:acd9cc727418b2f03e3dde312fe720902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in float array type out param.  <a href="#acd9cc727418b2f03e3dde312fe720902">More...</a><br /></td></tr>
<tr class="separator:acd9cc727418b2f03e3dde312fe720902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0a989bf09271d9d8c5dca011a50f56"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#afc0a989bf09271d9d8c5dca011a50f56">getFloatField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:afc0a989bf09271d9d8c5dca011a50f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in float type out param.  <a href="#afc0a989bf09271d9d8c5dca011a50f56">More...</a><br /></td></tr>
<tr class="separator:afc0a989bf09271d9d8c5dca011a50f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cbfe0abff9a11ab0dba3a7f2811b76"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#aa7cbfe0abff9a11ab0dba3a7f2811b76">getIntArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:aa7cbfe0abff9a11ab0dba3a7f2811b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int32_t array type out param.  <a href="#aa7cbfe0abff9a11ab0dba3a7f2811b76">More...</a><br /></td></tr>
<tr class="separator:aa7cbfe0abff9a11ab0dba3a7f2811b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d689517d1c5509fd81793d7e60f8c7"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a29d689517d1c5509fd81793d7e60f8c7">getIntField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a29d689517d1c5509fd81793d7e60f8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int32_t type out param.  <a href="#a29d689517d1c5509fd81793d7e60f8c7">More...</a><br /></td></tr>
<tr class="separator:a29d689517d1c5509fd81793d7e60f8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf377486f21a985b6f987e094661a5f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a8cf377486f21a985b6f987e094661a5f">getLongArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a8cf377486f21a985b6f987e094661a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int64_t array type out param.  <a href="#a8cf377486f21a985b6f987e094661a5f">More...</a><br /></td></tr>
<tr class="separator:a8cf377486f21a985b6f987e094661a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048862c6d5c7dffcec5588ddf09abd29"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a048862c6d5c7dffcec5588ddf09abd29">getLongField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a048862c6d5c7dffcec5588ddf09abd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int64_t type out param.  <a href="#a048862c6d5c7dffcec5588ddf09abd29">More...</a><br /></td></tr>
<tr class="separator:a048862c6d5c7dffcec5588ddf09abd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2fa8400f94e360ccc2b7f2cff7b94"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="a00761.html">PdxSerializable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a1ff2fa8400f94e360ccc2b7f2cff7b94">getObject</a> ()=0</td></tr>
<tr class="memdesc:a1ff2fa8400f94e360ccc2b7f2cff7b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes and returns the domain object that this instance represents.  <a href="#a1ff2fa8400f94e360ccc2b7f2cff7b94">More...</a><br /></td></tr>
<tr class="separator:a1ff2fa8400f94e360ccc2b7f2cff7b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b4f971f0dda9432cdd3dc3483f9ec"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#ae92b4f971f0dda9432cdd3dc3483f9ec">getShortArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:ae92b4f971f0dda9432cdd3dc3483f9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int16_t array type out param.  <a href="#ae92b4f971f0dda9432cdd3dc3483f9ec">More...</a><br /></td></tr>
<tr class="separator:ae92b4f971f0dda9432cdd3dc3483f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf05fa56e7128aa8219db633d934e4d5"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#adf05fa56e7128aa8219db633d934e4d5">getShortField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:adf05fa56e7128aa8219db633d934e4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int16_t type out param.  <a href="#adf05fa56e7128aa8219db633d934e4d5">More...</a><br /></td></tr>
<tr class="separator:adf05fa56e7128aa8219db633d934e4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ad356ea7d96e2fb7dfd180bf5702ec"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a22ad356ea7d96e2fb7dfd180bf5702ec">getStringArrayField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a22ad356ea7d96e2fb7dfd180bf5702ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field as a string array.  <a href="#a22ad356ea7d96e2fb7dfd180bf5702ec">More...</a><br /></td></tr>
<tr class="separator:a22ad356ea7d96e2fb7dfd180bf5702ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eea18635e71b38cfef5caa0834a712b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a6eea18635e71b38cfef5caa0834a712b">getStringField</a> (const std::string &amp;fieldname) const =0</td></tr>
<tr class="memdesc:a6eea18635e71b38cfef5caa0834a712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in std::string type out param.  <a href="#a6eea18635e71b38cfef5caa0834a712b">More...</a><br /></td></tr>
<tr class="separator:a6eea18635e71b38cfef5caa0834a712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051726c7e0dfc684cf8141e0ae4c5235"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235">hasField</a> (const std::string &amp;fieldname)=0</td></tr>
<tr class="memdesc:a051726c7e0dfc684cf8141e0ae4c5235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field exists and returns the result.  <a href="#a051726c7e0dfc684cf8141e0ae4c5235">More...</a><br /></td></tr>
<tr class="separator:a051726c7e0dfc684cf8141e0ae4c5235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7cd1603dcb22930cf0c3d32abe4c70"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a5d7cd1603dcb22930cf0c3d32abe4c70">hashcode</a> () const override=0</td></tr>
<tr class="memdesc:a5d7cd1603dcb22930cf0c3d32abe4c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hashcode based on the identity fields of this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#a5d7cd1603dcb22930cf0c3d32abe4c70">More...</a><br /></td></tr>
<tr class="separator:a5d7cd1603dcb22930cf0c3d32abe4c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a9cdd92ccdd12ec2f2f984c64d1791"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#ae7a9cdd92ccdd12ec2f2f984c64d1791">isIdentityField</a> (const std::string &amp;fieldname)=0</td></tr>
<tr class="memdesc:ae7a9cdd92ccdd12ec2f2f984c64d1791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field was <a class="el" href="a00777.html#a4284cab342603084f26e40658ee66819">PdxWriter#markIdentityField</a>marked as an identity field.  <a href="#ae7a9cdd92ccdd12ec2f2f984c64d1791">More...</a><br /></td></tr>
<tr class="separator:ae7a9cdd92ccdd12ec2f2f984c64d1791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147bbc2fa40218981d1e4c9a0eaed512"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a147bbc2fa40218981d1e4c9a0eaed512">objectSize</a> () const override=0</td></tr>
<tr class="separator:a147bbc2fa40218981d1e4c9a0eaed512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00654c7ddd97e35970bac9d8fa92c8b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a00654c7ddd97e35970bac9d8fa92c8b6">operator==</a> (const <a class="el" href="a00341.html">CacheableKey</a> &amp;other) const override=0</td></tr>
<tr class="memdesc:a00654c7ddd97e35970bac9d8fa92c8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="a00341.html" title="Represents a cacheable key.">CacheableKey</a> derived object is equals to this instance.  <a href="#a00654c7ddd97e35970bac9d8fa92c8b6">More...</a><br /></td></tr>
<tr class="separator:a00654c7ddd97e35970bac9d8fa92c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245bb68e028ee085a78bf1759c009f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#aa245bb68e028ee085a78bf1759c009f6">toData</a> (<a class="el" href="a00777.html">PdxWriter</a> &amp;output) const override=0</td></tr>
<tr class="memdesc:aa245bb68e028ee085a78bf1759c009f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize this object in geode PDX format.  <a href="#aa245bb68e028ee085a78bf1759c009f6">More...</a><br /></td></tr>
<tr class="separator:aa245bb68e028ee085a78bf1759c009f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a4f63885e135d281474d09f33023d8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a21a4f63885e135d281474d09f33023d8">toString</a> () const override=0</td></tr>
<tr class="memdesc:a21a4f63885e135d281474d09f33023d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out all of the identity fields of this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>.  <a href="#a21a4f63885e135d281474d09f33023d8">More...</a><br /></td></tr>
<tr class="separator:a21a4f63885e135d281474d09f33023d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db54dacfcca94c3091c273f188ec73b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a4db54dacfcca94c3091c273f188ec73b">~PdxInstance</a> () override=default</td></tr>
<tr class="memdesc:a4db54dacfcca94c3091c273f188ec73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#a4db54dacfcca94c3091c273f188ec73b">More...</a><br /></td></tr>
<tr class="separator:a4db54dacfcca94c3091c273f188ec73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a562c8827c49b9808ca4a601a48b944b6"><td class="memTemplParams" colspan="2">template&lt;class _T &gt; </td></tr>
<tr class="memitem:a562c8827c49b9808ca4a601a48b944b6"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="a00341.html">CacheableKey</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00341.html#a562c8827c49b9808ca4a601a48b944b6">create</a> (_T value)</td></tr>
<tr class="memdesc:a562c8827c49b9808ca4a601a48b944b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that creates the key type that matches the type of value.  <a href="#a562c8827c49b9808ca4a601a48b944b6">More...</a><br /></td></tr>
<tr class="separator:a562c8827c49b9808ca4a601a48b944b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b42b5b55a798df561f9031e2b4f602"><td class="memTemplParams" colspan="2">template&lt;class _T &gt; </td></tr>
<tr class="memitem:ac6b42b5b55a798df561f9031e2b4f602"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="a00853.html">Serializable</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00853.html#ac6b42b5b55a798df561f9031e2b4f602">create</a> (_T value)</td></tr>
<tr class="memdesc:ac6b42b5b55a798df561f9031e2b4f602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that creates the <a class="el" href="a00853.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a> object that matches the type of value.  <a href="#ac6b42b5b55a798df561f9031e2b4f602">More...</a><br /></td></tr>
<tr class="separator:ac6b42b5b55a798df561f9031e2b4f602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6c8bac397a692f7bee30641c0b6c92e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00749.html#a6c8bac397a692f7bee30641c0b6c92e9">PdxInstance</a> ()</td></tr>
<tr class="memdesc:a6c8bac397a692f7bee30641c0b6c92e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructors  <a href="#a6c8bac397a692f7bee30641c0b6c92e9">More...</a><br /></td></tr>
<tr class="separator:a6c8bac397a692f7bee30641c0b6c92e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> provides run time access to the fields of a PDX without deserializing the PDX. </p>
<p>Preventing deserialization saves time and memory. The <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> implementation is a light weight wrapper that simply refers to the raw bytes of the PDX that are kept in the cache. Applications can choose to access PdxInstances instead of C++ objects by configuring the <a class="el" href="a00289.html" title="Caches are obtained from the create method on the CacheFactory#create class.">Cache</a> to prefer PDX instances during deserialization. This can be done in <code>cache.xml</code> by setting the attribute <code>read-serialized</code> to true on the <code>pdx</code> element. Or it can be done programmatically using <a class="el" href="">setPdxReadSerialized</a> method. Once this preference is configured, then any time deserialization of a PDX is done it will deserialize into a <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> are immutable. If you want to change one call <a class="el" href="a00749.html#af8e8a42bfedd76fec24cfff33fbdd93a">createWriter</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4db54dacfcca94c3091c273f188ec73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db54dacfcca94c3091c273f188ec73b">&#9670;&nbsp;</a></span>~PdxInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">apache::geode::client::PdxInstance::~PdxInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>

</div>
</div>
<a id="a6c8bac397a692f7bee30641c0b6c92e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8bac397a692f7bee30641c0b6c92e9">&#9670;&nbsp;</a></span>PdxInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">apache::geode::client::PdxInstance::PdxInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructors </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a562c8827c49b9808ca4a601a48b944b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562c8827c49b9808ca4a601a48b944b6">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="a00341.html">CacheableKey</a>&gt; apache::geode::client::CacheableKey::create </td>
          <td>(</td>
          <td class="paramtype">_T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method that creates the key type that matches the type of value. </p>
<p>For user defined derivations of <a class="el" href="a00341.html" title="Represents a cacheable key.">CacheableKey</a>, the method <a class="el" href="a00341.html#a562c8827c49b9808ca4a601a48b944b6" title="Factory method that creates the key type that matches the type of value.">apache::geode::client::CacheableKey::create</a> may be overloaded. </p>

</div>
</div>
<a id="ac6b42b5b55a798df561f9031e2b4f602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b42b5b55a798df561f9031e2b4f602">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="a00853.html">Serializable</a>&gt; apache::geode::client::Serializable::create </td>
          <td>(</td>
          <td class="paramtype">_T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method that creates the <a class="el" href="a00853.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a> object that matches the type of value. </p>
<p>For user defined derivations of <a class="el" href="a00853.html" title="This base class is the superclass of all user objects in the cache that can be serialized.">Serializable</a>, the method <a class="el" href="a00853.html#ac6b42b5b55a798df561f9031e2b4f602" title="Factory method that creates the Serializable object that matches the type of value.">apache::geode::client::Serializable::create</a> may be overloaded. </p>

</div>
</div>
<a id="af8e8a42bfedd76fec24cfff33fbdd93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e8a42bfedd76fec24cfff33fbdd93a">&#9670;&nbsp;</a></span>createWriter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00881.html">WritablePdxInstance</a>&gt; apache::geode::client::PdxInstance::createWriter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="a00881.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<p>This call returns a copy of the current field values so modifications made to the returned value will not modify this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="a00881.html">WritablePdxInstance</a> </dd></dl>

</div>
</div>
<a id="aa3e789d8e4da85f4ec586bd16b737001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e789d8e4da85f4ec586bd16b737001">&#9670;&nbsp;</a></span>fromData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::fromData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00757.html">PdxReader</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize this object. </p>
<p>This is an internal method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a00757.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX.">PdxReader</a></td><td>to Deserialize the PDX object </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00761.html#aa2429785803446f892d6669d7ebab795">apache::geode::client::PdxSerializable</a>.</p>

</div>
</div>
<a id="ad6a96b719b63a9cbc7eb63f2781cae7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a96b719b63a9cbc7eb63f2781cae7d">&#9670;&nbsp;</a></span>getBooleanArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;bool&gt; apache::geode::client::PdxInstance::getBooleanArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in bool array type out param. </p>
<p>bool* type is corresponding to java boolean[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with bool array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of bool elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a14050655be9f0e5d0b98ca8cd58ebe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14050655be9f0e5d0b98ca8cd58ebe7f">&#9670;&nbsp;</a></span>getBooleanField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::getBooleanField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in bool type out param. </p>
<p>bool type is corresponding to java boolean type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with bool type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a6a5367cf178da27aecddc44ac48ce595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5367cf178da27aecddc44ac48ce595">&#9670;&nbsp;</a></span>getByteArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int8_t&gt; apache::geode::client::PdxInstance::getByteArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in signed char array type out param. </p>
<p>int8_t* type is corresponding to java byte[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int8_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of int8_t elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a48742741670329aba1d48b25964f2789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48742741670329aba1d48b25964f2789">&#9670;&nbsp;</a></span>getByteField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t apache::geode::client::PdxInstance::getByteField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in signed char type out param. </p>
<p>signed char type is corresponding to java byte type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with signed char type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="ad813be08753e160b30b0353c9cc5cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad813be08753e160b30b0353c9cc5cd0c">&#9670;&nbsp;</a></span>getCacheableDateField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00329.html">CacheableDate</a>&gt; apache::geode::client::PdxInstance::getCacheableDateField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in std::shared_ptr&lt;CacheableDate&gt; type out param. </p>
<p>std::shared_ptr&lt;CacheableDate&gt; type is corresponding to java Java.util.date type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with std::shared_ptr&lt;CacheableDate&gt; type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="affbe4efe8ed166011ff68a76e78ba96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbe4efe8ed166011ff68a76e78ba96c">&#9670;&nbsp;</a></span>getCacheableField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00853.html">Cacheable</a>&gt; apache::geode::client::PdxInstance::getCacheableField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in std::shared_ptr&lt;Cacheable&gt; type out param. </p>
<p>std::shared_ptr&lt;Cacheable&gt; type is corresponding to java object type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with std::shared_ptr&lt;Cacheable&gt; type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field. For deserialization C++ Native Client requires the domain class to be registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd>
<dd>
<a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a08b598e4b18862e6e6788a6ba24a05d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b598e4b18862e6e6788a6ba24a05d0">&#9670;&nbsp;</a></span>getCacheableObjectArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00357.html">CacheableObjectArray</a>&gt; apache::geode::client::PdxInstance::getCacheableObjectArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in std::shared_ptr&lt;CacheableObjectArray&gt; type out param. </p>
<p>For deserialization C++ Native Client requires the domain class to be registered. std::shared_ptr&lt;CacheableObjectArray&gt; type is corresponding to java Object[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read. </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with std::shared_ptr&lt;CacheableObjectArray&gt; type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd>
<dd>
<a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="ae9cc4bf08dbaceb3cd8b59b5015b364f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cc4bf08dbaceb3cd8b59b5015b364f">&#9670;&nbsp;</a></span>getCharArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;char16_t&gt; apache::geode::client::PdxInstance::getCharArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in char array type out param. </p>
<p>char16_t* type is corresponding to java char[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with char array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of char16_t* elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="ad88b879c6497ebea32d09be9a85964d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88b879c6497ebea32d09be9a85964d3">&#9670;&nbsp;</a></span>getCharField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char16_t apache::geode::client::PdxInstance::getCharField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in char type out param. </p>
<p>char type is corresponding to java char type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with char type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a2912c23ab766cb21e711088dd3b0c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2912c23ab766cb21e711088dd3b0c1fb">&#9670;&nbsp;</a></span>getClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; apache::geode::client::PdxInstance::getClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the full name of the class that this pdx instance represents. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the class that this pdx instance represents. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> typeid is not defined yet, to get classname or if PdxType is not defined for <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00761.html#acb3cecbfb02d3983c04551850ba7b84c">apache::geode::client::PdxSerializable</a>.</p>

</div>
</div>
<a id="a9ba80875c282330e1d20e7846506ec70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba80875c282330e1d20e7846506ec70">&#9670;&nbsp;</a></span>getDoubleArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;double&gt; apache::geode::client::PdxInstance::getDoubleArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in double array type out param. </p>
<p>double* type is corresponding to java double[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with double array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of double elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="accdaa0cbd2791e46eb56b34f7d945bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdaa0cbd2791e46eb56b34f7d945bfa">&#9670;&nbsp;</a></span>getDoubleField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double apache::geode::client::PdxInstance::getDoubleField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in double type out param. </p>
<p>double type is corresponding to java double type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with double type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a676bf0537b037822cc335e69068c078a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676bf0537b037822cc335e69068c078a">&#9670;&nbsp;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t ***&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&amp;&#160;</td>
          <td class="paramname"><em>elementLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in array of byte arrays type out param. </p>
<p>int8_t** type is corresponding to java byte[][] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read. </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with array of byte arrays type. </td></tr>
    <tr><td class="paramname">arrayLength</td><td>arrayLength is set to the number of byte arrays. </td></tr>
    <tr><td class="paramname">elementLength</td><td>elementLength is set to individual byte array lengths. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="aef3cb5ba5c09771f1cc30238e54a7c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3cb5ba5c09771f1cc30238e54a7c3d">&#9670;&nbsp;</a></span>getFieldNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00026.html#abb5c1ce32786fe2c0f7793809b103737">CacheableStringArray</a>&gt; apache::geode::client::PdxInstance::getFieldNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an unmodifiable list of the field names on this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>an unmodifiable list of the field names on this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> </dd></dl>

</div>
</div>
<a id="acc3cce44ea9beec3803807e5ab744723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3cce44ea9beec3803807e5ab744723">&#9670;&nbsp;</a></span>getFieldType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PdxFieldTypes apache::geode::client::PdxInstance::getFieldType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type. </p>
<dl class="section see"><dt>See also</dt><dd>PdxInstance::PdxFieldTypes of the field in the pdx instance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the type </dd></dl>
<dl class="section see"><dt>See also</dt><dd>PdxInstance::PdxFieldTypes of the field in the pdx instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> typeid is not defined yet, to get classname or if PdxType is not defined for <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd9cc727418b2f03e3dde312fe720902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9cc727418b2f03e3dde312fe720902">&#9670;&nbsp;</a></span>getFloatArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;float&gt; apache::geode::client::PdxInstance::getFloatArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in float array type out param. </p>
<p>float* type is corresponding to java float[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with float array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of float elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="afc0a989bf09271d9d8c5dca011a50f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0a989bf09271d9d8c5dca011a50f56">&#9670;&nbsp;</a></span>getFloatField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float apache::geode::client::PdxInstance::getFloatField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in float type out param. </p>
<p>float type is corresponding to java float type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with float type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="aa7cbfe0abff9a11ab0dba3a7f2811b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cbfe0abff9a11ab0dba3a7f2811b76">&#9670;&nbsp;</a></span>getIntArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int32_t&gt; apache::geode::client::PdxInstance::getIntArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int32_t array type out param. </p>
<p>int32_t* type is corresponding to java int[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int32_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of int32_t elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a29d689517d1c5509fd81793d7e60f8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d689517d1c5509fd81793d7e60f8c7">&#9670;&nbsp;</a></span>getIntField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::PdxInstance::getIntField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int32_t type out param. </p>
<p>int32_t type is corresponding to java int type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int32_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cf377486f21a985b6f987e094661a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf377486f21a985b6f987e094661a5f">&#9670;&nbsp;</a></span>getLongArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int64_t&gt; apache::geode::client::PdxInstance::getLongArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int64_t array type out param. </p>
<p>int64_t* type is corresponding to java long[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int64_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of int64_t elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a048862c6d5c7dffcec5588ddf09abd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048862c6d5c7dffcec5588ddf09abd29">&#9670;&nbsp;</a></span>getLongField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t apache::geode::client::PdxInstance::getLongField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int64_t type out param. </p>
<p>int64_t type is corresponding to java long type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int64_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a1ff2fa8400f94e360ccc2b7f2cff7b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff2fa8400f94e360ccc2b7f2cff7b94">&#9670;&nbsp;</a></span>getObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="a00761.html">PdxSerializable</a>&gt; apache::geode::client::PdxInstance::getObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes and returns the domain object that this instance represents. </p>
<p>For deserialization C++ Native Client requires the domain class to be registered. </p><dl class="section return"><dt>Returns</dt><dd>the deserialized domain object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

</div>
</div>
<a id="ae92b4f971f0dda9432cdd3dc3483f9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92b4f971f0dda9432cdd3dc3483f9ec">&#9670;&nbsp;</a></span>getShortArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int16_t&gt; apache::geode::client::PdxInstance::getShortArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int16_t array type out param. </p>
<p>int16_t* type is corresponding to java short[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int16_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of int16_t elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="adf05fa56e7128aa8219db633d934e4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf05fa56e7128aa8219db633d934e4d5">&#9670;&nbsp;</a></span>getShortField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t apache::geode::client::PdxInstance::getShortField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int16_t type out param. </p>
<p>int16_t type is corresponding to java short type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int16_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a22ad356ea7d96e2fb7dfd180bf5702ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ad356ea7d96e2fb7dfd180bf5702ec">&#9670;&nbsp;</a></span>getStringArrayField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; apache::geode::client::PdxInstance::getStringArrayField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field as a string array. </p>
<p>std::vector&lt;std::string&gt; type is corresponding to java String[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a6eea18635e71b38cfef5caa0834a712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eea18635e71b38cfef5caa0834a712b">&#9670;&nbsp;</a></span>getStringField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string apache::geode::client::PdxInstance::getStringField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in std::string type out param. </p>
<p>std::string type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string value for field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00749.html#a051726c7e0dfc684cf8141e0ae4c5235" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a id="a051726c7e0dfc684cf8141e0ae4c5235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051726c7e0dfc684cf8141e0ae4c5235">&#9670;&nbsp;</a></span>hasField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::hasField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field exists and returns the result. </p>
<p>This can be useful when writing code that handles more than one version of a PDX class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a5d7cd1603dcb22930cf0c3d32abe4c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7cd1603dcb22930cf0c3d32abe4c70">&#9670;&nbsp;</a></span>hashcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::PdxInstance::hashcode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a hashcode based on the identity fields of this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<p>If a <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> has marked identity fields using {<a class="el" href="a00777.html#a4284cab342603084f26e40658ee66819">} then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. </a> For deserialization C++ Native Client requires the domain class to be registered. If the field is an array then all array elements are used for hashcode computation. Otherwise the raw bytes of its value are used to compute the hash code. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the field contains an element that is not of <a class="el" href="a00341.html" title="Represents a cacheable key.">CacheableKey</a> derived type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

<p>Implements <a class="el" href="a00341.html#aff9da784fe4916ea44340e247e0a0bb3">apache::geode::client::CacheableKey</a>.</p>

</div>
</div>
<a id="ae7a9cdd92ccdd12ec2f2f984c64d1791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9cdd92ccdd12ec2f2f984c64d1791">&#9670;&nbsp;</a></span>isIdentityField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::isIdentityField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field was <a class="el" href="a00777.html#a4284cab342603084f26e40658ee66819">PdxWriter#markIdentityField</a>marked as an identity field. </p>
<p>Note that if no fields have been marked then all the fields are used as identity fields even though this method will return <code>false</code> since none of them have been <em>marked</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a id="a147bbc2fa40218981d1e4c9a0eaed512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147bbc2fa40218981d1e4c9a0eaed512">&#9670;&nbsp;</a></span>objectSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t apache::geode::client::PdxInstance::objectSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the object in bytes This is an internal method. It is used in case of heap LRU property is set. </dd></dl>

<p>Reimplemented from <a class="el" href="a00853.html#aa1e74dde03eb0d3fb17752bfdcd347ef">apache::geode::client::Serializable</a>.</p>

</div>
</div>
<a id="a00654c7ddd97e35970bac9d8fa92c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00654c7ddd97e35970bac9d8fa92c8b6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00341.html">CacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="a00341.html" title="Represents a cacheable key.">CacheableKey</a> derived object is equals to this instance. </p>
<p>If <code>other</code> is not a <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> then it is not equal to this instance. NOTE: Even if <code>other</code> is the result of calling {<a class="el" href="a00749.html#a1ff2fa8400f94e360ccc2b7f2cff7b94">} it will not be equal to this instance</a>. </p>
<p>Otherwise equality of two PdxInstances is determined as follows: </p><ol>
<li>
The domain class name must be equal for both PdxInstances </li>
<li>
Each identity field must be equal. </li>
</ol>
<p>If one of the instances does not have a field that the other one does then equals will assume it has the field with a default value. If a <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> has marked identity fields using {<a class="el" href="a00777.html#a4284cab342603084f26e40658ee66819">markIdentityField} then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. </a>An identity field is equal if all the following are true: </p><ol>
<li>
The field name is equal. </li>
<li>
The field type is equal. </li>
<li>
The field value is equal. </li>
</ol>
<p>If an identity field is of type derived from <code>Cacheable</code> then it is deserialized. For deserialization C++ Native Client requires the domain class to be registered. If the deserialized object is an array then all array elements are used to determine equality. If an identity field is of type <code><a class="el" href="a00357.html" title="Implements an immutable Vector of Cacheable objects that can serve as a distributable object for cach...">CacheableObjectArray</a></code> then it is deserialized and all array elements are used to determine equality. For all other field types the value does not need to be deserialized. Instead the serialized raw bytes are compared and used to determine equality. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other instance to compare to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this instance is equal to <code>other</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00477.html" title="Thrown when the state of cache is manipulated to be illegal.">IllegalStateException</a></td><td>if the field contains an element that is not of <a class="el" href="a00341.html" title="Represents a cacheable key.">CacheableKey</a> derived type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

<p>Implements <a class="el" href="a00341.html#a508b0eef9d80aeda9edf877880c0705f">apache::geode::client::CacheableKey</a>.</p>

</div>
</div>
<a id="aa245bb68e028ee085a78bf1759c009f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245bb68e028ee085a78bf1759c009f6">&#9670;&nbsp;</a></span>toData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::toData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00777.html">PdxWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialize this object in geode PDX format. </p>
<p>This is an internal method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a00777.html" title="A PdxWriter will be passed to PdxSerializable.toData when it is serializing the domain class.">PdxWriter</a></td><td>to serialize the PDX object </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00761.html#a28894ac9e842832bcb336915ae3983e0">apache::geode::client::PdxSerializable</a>.</p>

</div>
</div>
<a id="a21a4f63885e135d281474d09f33023d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a4f63885e135d281474d09f33023d8">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string apache::geode::client::PdxInstance::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints out all of the identity fields of this <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a>. </p>
<p>If a <a class="el" href="a00749.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX.">PdxInstance</a> has marked identity fields using {<a class="el" href="a00777.html#a4284cab342603084f26e40658ee66819">} then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields</a>. For deserialization C++ Native Client requires the domain class to be registered.</p>
<dl class="section see"><dt>See also</dt><dd>serializationRegistry-&gt;addPdxType </dd></dl>

<p>Reimplemented from <a class="el" href="a00853.html#ac7a8d506b1a6f8313302b5efd0990378">apache::geode::client::Serializable</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<HR><address style="align: right;"><small>Apache Geode C++ Cache API Documentation</small></address>
